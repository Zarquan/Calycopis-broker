#
# <meta:header>
#   <meta:licence>
#     Copyright (c) 2025, Manchester (http://www.manchester.ac.uk/)
#
#     This information is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This information is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#zrq-notes-indent
#
# AIMetrics: []
#

    Target:

        Success

    Result:

        Work in progress ...

    Resources:

        Guide to Spring Retry
        https://www.baeldung.com/spring-retry



# -----------------------------------------------------
# Create a new branch.
#[user@desktop]

    branchname=processing-steps
    newbranch=$(date '+%Y%m%d')-zrq-${branchname:?}

    source "${HOME:?}/calycopis.env"
    pushd "${CALYCOPIS_CODE}"

        git checkout main

        git checkout -b "${newbranch:?}"

    popd

    source "${HOME:?}/calycopis.env"
    pushd "${TREBULA_CODE}"

        git checkout main

        git checkout -b "${newbranch:?}"

    popd

# -----------------------------------------------------
# Run an instance of the developer tools.
#[user@desktop]

    source "${HOME:?}/calycopis.env"
    podman run \
        --rm \
        --tty \
        --interactive \
        --publish 8082:8082 \
        --name developer-tools \
        --volume "${TREBULA_CODE}:/trebula:rw,z" \
        --volume "${ISOBEON_CODE}:/isobeon:rw,z" \
        --volume "${CALYCOPIS_CODE}:/calycopis:rw,z" \
        --volume "${HOME}/.m2/repository:/root/.m2/repository:rw,z" \
        ghcr.io/ivoa/calycopis/developer-tools:2025.08.12 \
        bash

    >   ....
    >   ....


# -----------------------------------------------------
# Update the version in the Maven POM.
#[root@developer-tools]

    newversion=0.0.1-SNAPSHOT-$(date '+%Y%m%d')

    # TODO This moves to the schema project.
    pushd /calycopis/java/spring/spring-openapi

        sed -i '
            /<\/parent>/, /<properties>/ {
                s/<version>.*<\/version>/<version>'${newversion:?}'<\/version>/
                }
            ' pom.xml

    popd

    pushd /calycopis/java/spring/spring-webapp

        sed -i '
            /<\/parent>/, /<properties>/ {
                s/<version>.*<\/version>/<version>'${newversion:?}'<\/version>/
                }
            ' pom.xml

    popd


# -----------------------------------------------------
# Build the combined schema.
#[root@developer-tools]

        source=/trebula/schema/v1.0
        target=/trebula/target/

        rm -rf "${target:?}"
        mkdir  "${target:?}"

        /isobeon/schema-processor.py \
            "${source}/execution-broker.yaml" \
            "${target}/execution-broker-${newversion}.yaml"

        ls -al "${target}"

    >   ....
    >   ....


# -----------------------------------------------------
# Copy the combined schema back into the Java project.
#[root@developer-tools]

    #
    # Note - using symlinks works inside the container, but breaks the Eclipse build.
    # Although not a problem because we don't need the Eclipse build for anything.
    # TODO Move the Maven project into the schema project and install a jar.
    #

    pushd /calycopis/java/spring/spring-openapi
        pushd openapi

            rm -rf target

            cp -r /trebula/target target

            ls -al target

        popd
    popd


# -----------------------------------------------------
# Build the Java service API.
#[root@developer-tools]

    #
    # TODO This moves to the schema project.
    #

    pushd /calycopis/java/spring/spring-openapi ; ./mvnw clean install ; popd

        ....
        ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

        ....
        ....



# -----------------------------------------------------

    Based on ChatGPT's suggestions


        @Transactional
        void prepareOperation()
            {
            // Load the values we need from our entities.
            }

        abstract void performOperation()
            {
            // Perform the external thing
            }

        @Retryable(maxAttempts = 3, value = LockTimeoutException.class)
        @Transactional
        abstract public void updateInventory(...)
            {
            // Save the results in our entities.
            }

        @Recover
        public void recover(LockTimeoutException ex, Long itemId, int deltaQty)
            {
            failOperation();
            }

        @Retryable(maxAttempts = 3, value = LockTimeoutException.class)
        @Transactional
        public void failOperation(...)
            {
            // Mark the operation as failed to prevent it being loaded again.
            }

        @Recover
        public void recover(LockTimeoutException ex, Long itemId, int deltaQty)
            {
            // Record the failure in a log.
            // Manual intervention to fix it.
            }

# -----------------------------------------------------

    table processingsteps
    AbstractProcessingStep

        URI  kind
        UUID uuid
        UUID handler
        enum ProcessingStepPhase phase
            DORMANT     Not done anything yet
            WAITING     Waiting for something else ?
            ACTIVE      Doing stuff
            COMPLETED
            FAILED
        DateTime created
        DateTime modified
        DateTime activation

    AbstractProcessingHandler

        URI  kind
        UUID uuid

            #
            # Find the next step assigned to this handler.
            SELECT
                uuid
            FROM
                processingsteps
            WHERE
                handler = this
            AND
                phase = ACTIVE
            ORDER BY
                activation ASC
            LIMIT
                1

            #
            # Find the next unassigned step.
            SELECT
                uuid
            FROM
                processingsteps
            WHERE
                kind = this.kind
            AND
                phase = ACTIVE
            AND
                handler IS NULL
            ORDER BY
                activation ASC
            LIMIT
                1

            #
            # Claim the next unassigned step.
            UPDATE
                processingsteps
            SET
                phase = ACTIVE
                handler = this
            WHERE
                uuid = (
                    SELECT
                        uuid
                    FROM
                        processingsteps
                    WHERE
                        kind  = this.kind
                    AND
                        phase = ACTIVE
                    AND
                        handler IS NULL
                    AND
                        activation > now
                    ORDER BY
                        activation ASC
                    LIMIT
                        1
                    )


# -----------------------------------------------------


    AbstractPlatform

    FictionalPlatform
    extends Abstractlatform


    AbstractOperation

        URI  getKind()
        UUID getUuid()
        UUID getHandlerUuid()
        Phase getPhase()
            DORMANT     Not done anything yet
            WAITING     Waiting for something else ?
            ACTIVE      Doing stuff
            COMPLETED
            FAILED
        DateTime getCreated()
        DateTime getModified()
        DateTime getActivation()


    table AbstractOperationImpl
    AbstractOperationImpl
    implements AbstractOperation

        URI  kind
        UUID uuid
        UUID handler
        enum ProcessingStepPhase phase
            DORMANT     Not done anything yet
            WAITING     Waiting for something else ?
            ACTIVE      Doing stuff
            COMPLETED
            FAILED
        DateTime created
        DateTime modified
        DateTime activation


    AbstractOperationHandler

        URI  getKind()
        UUID getUuid()


    AbstractOperationHandlerImpl

        URI  getKind()
        UUID getUuid()

        private final InnerAbstractOperationHandlerImpl inner ;

        @Autowired
        AbstractOperationHandlerImpl(
            final InnerAbstractOperationHandlerImpl inner
            ){
            this.inner = inner;
            }

        @Slf4j
        @Component
        static class InnerAbstractOperationHandlerImpl
            {

            // Stuff ...
            private final ScheduledExecutionSessionEntityRepository sessionRepository;
            private final AsyncComputeHandler computeHandler;
            private final AsyncExecutableHandler executableHandler;
            private final AsyncStorageResourceHandler storageHandler;

            @Autowired
            InnerOperationHandlerImpl(
                final ScheduledExecutionSessionEntityRepository sessionRepository,
                final AsyncComputeHandler computeHandler,
                final AsyncExecutableHandler executableHandler,
                final AsyncStorageResourceHandler storageHandler
                ){
                this.sessionRepository = sessionRepository;
                this.computeHandler    = computeHandler;
                this.executableHandler = executableHandler;
                this.storageHandler    = storageHandler;
                }

            // Load the values we need from our entities.
            abstract void prepareOperation(AbstractOperation operation)

            // Perform the external thing.
            abstract void performOperation(AbstractOperation operation)

            // Save the results in our entities.
            abstract public void updateEntities(AbstractOperation operation)

            @Retryable(maxAttempts = 3, value = LockTimeoutException.class)
            @Transactional
            public void failOperation(AbstractOperation operation)
                {
                // Mark the operation as failed to prevent it being loaded again.
                }

            @Recover
            public void recover(LockTimeoutException ex, Long itemId, int deltaQty)
                {
                // Record the failure in a log.
                // Manual intervention to fix it.
                }
            }
        }

    Nice and abstract.
    Need to tie it down to real (fictional) cases.

    ExecutionSession
    ExecutionSessionEntity

        List of Operations linked to this session.

        FPSessionOperation

            // Does stuff depending on the Session state

            // Heading towards one Operator per Component








    table FictionalSessionOperation
    FictionalSessionOperationImpl

        UUID getSessionUuid();
        AbstractExecutionSession getSession();
        AbstractExecutionSessionEntity getSessionEntity();


    FictionalSessionOperationHandler
    extends AbstractOperationHandler


    FictionalSessionOperationHandlerImpl
    extends AbstractOperationHandlerImpl













    FictionalSessionActivation

        URI  getKind()
        UUID getUuid()

        @Transactional
        void prepareOperation()
            {
            // Load the values we need from our entities.
            }

        abstract void performOperation()
            {
            // Perform the external thing
            }

        @Retryable(maxAttempts = 3, value = LockTimeoutException.class)
        @Transactional
        abstract public void updateInventory(...)
            {
            // Save the results in our entities.
            }

        @Recover
        public void recover(LockTimeoutException ex, Long itemId, int deltaQty)
            {
            failOperation();
            }

        @Retryable(maxAttempts = 3, value = LockTimeoutException.class)
        @Transactional
        public void failOperation(...)
            {
            // Mark the operation as failed to prevent it being loaded again.
            }

        @Recover
        public void recover(LockTimeoutException ex, Long itemId, int deltaQty)
            {
            // Record the failure in a log.
            // Manual intervention to fix it.
            }


    #
    # Heading towards a single Operator linked to a Component.
    # A PlatformComponentTypeOperator looks after a Component.
    # Handles the Component lifecycle from creation to release.
    # Put back into the queue several times.
    # Takes appropriate actions based on the Component state.
    #

    CanfarExecutionSession == SkahaSession
    Compute resource is a data component
    Adjusts the cpu and memory to match the available options.
    CanfarExecutionSessionOperator launches the Skaha session.







