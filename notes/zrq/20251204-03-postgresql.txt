#
# <meta:header>
#   <meta:licence>
#     Copyright (c) 2025, Manchester (http://www.manchester.ac.uk/)
#
#     This information is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This information is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#zrq-notes-indent
#
# AIMetrics: []
#

    Target:

        Change our database to use PostgreSQL.

    Result:

        Work in progress ...

# -----------------------------------------------------
# Create new branches.
#[user@desktop]

    branchname=processing-loop
    newbranch=$(date '+%Y%m%d')-zrq-${branchname:?}

    source "${HOME:?}/calycopis.env"
    pushd "${CALYCOPIS_CODE}"

        git checkout main

        git checkout -b "${newbranch:?}"

    popd

    source "${HOME:?}/calycopis.env"
    pushd "${TREBULA_CODE}"

        git checkout main

        git checkout -b "${newbranch:?}"

    popd

# -----------------------------------------------------
# Run an instance of the developer tools.
#[user@desktop]

    source "${HOME:?}/calycopis.env"
    podman run \
        --rm \
        --tty \
        --interactive \
        --publish 8082:8082 \
        --name developer-tools \
        --volume "${TREBULA_CODE}:/trebula:rw,z" \
        --volume "${ISOBEON_CODE}:/isobeon:rw,z" \
        --volume "${CALYCOPIS_CODE}:/calycopis:rw,z" \
        --volume "${HOME}/.m2/repository:/root/.m2/repository:rw,z" \
        ghcr.io/ivoa/calycopis/developer-tools:2025.08.12 \
        bash

    >   ....
    >   ....


# -----------------------------------------------------
# Update the version in the Maven POM.
#[root@developer-tools]

    newversion=0.0.1-SNAPSHOT-$(date '+%Y%m%d')

    # TODO This moves to the schema project.
    pushd /calycopis/java/spring/spring-openapi

        sed -i '
            /<\/parent>/, /<properties>/ {
                s/<version>.*<\/version>/<version>'${newversion:?}'<\/version>/
                }
            ' pom.xml

    popd

    pushd /calycopis/java/spring/spring-webapp

        sed -i '
            /<\/parent>/, /<properties>/ {
                s/<version>.*<\/version>/<version>'${newversion:?}'<\/version>/
                }
            ' pom.xml

    popd


# -----------------------------------------------------
# Build the combined schema.
#[root@developer-tools]

        source=/trebula/schema/v1.0
        target=/trebula/target/

        rm -rf "${target:?}"
        mkdir  "${target:?}"

        /isobeon/schema-processor.py \
            "${source}/execution-broker.yaml" \
            "${target}/execution-broker-${newversion}.yaml"

        ls -al "${target}"

    >   ....
    >   ....


# -----------------------------------------------------
# Copy the combined schema back into the Java project.
#[root@developer-tools]

    #
    # Note - using symlinks works inside the container, but breaks the Eclipse build.
    # Although not a problem because we don't need the Eclipse build for anything.
    # TODO Move the Maven project into the schema project and install a jar.
    #

    pushd /calycopis/java/spring/spring-openapi
        pushd openapi

            rm -rf target

            cp -r /trebula/target target

            ls -al target

        popd
    popd


# -----------------------------------------------------
# Build the Java service API.
#[root@developer-tools]

    #
    # TODO This moves to the schema project.
    #

    pushd /calycopis/java/spring/spring-openapi ; ./mvnw clean install ; popd

        ....
        ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

        ....
        ....



# -----------------------------------------------------
# Launch second terminal ...
#[user@desktop]

    podman exec \
        --tty \
        --interactive \
        developer-tools \
            bash

        ....
        ....


# -----------------------------------------------------
# Run some tests
#[root@container]

    pushd "$(mktemp --directory)"

    cat > "001-offerset-request.yaml" << EOF
executable:
  kind: https://www.purl.org/ivoa.net/EB/schema/v1.0/types/executable/docker-container-1.0
  image:
    locations:
      - "ghcr.io/ivoa/oligia-webtop:ubuntu-2022.01.13"
    digest: sha256:5d22a47f43b2b5efc433554092de724bd6c3cf01d2c74038f6569770a5dd5245
schedule:
  requested:
    duration: PT1H
EOF

    cat > "003-accept-00-request.yaml" << EOF
kind: uri:enum-value-update
path: phase
value: ACCEPTED
EOF

        #
        # Create a new offerset.
        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@001-offerset-request.yaml" \
            --header 'Accept: application/yaml' \
            'http://127.0.0.1:8082/offersets' \
        | tee "002-offerset-response.yaml" \
        | yq '.'

        #
        # Accept the first offer.
        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@003-accept-00-request.yaml" \
            --header 'Accept: application/yaml' \
            "$(yq '.offers[0].meta.url' '002-offerset-response.yaml')" \
        | tee "004-accept-00-response.yaml" \
        | yq '.'

    >   ....
    >   ....


# -----------------------------------------------------
# Wrap the steps in a function and call it lots of times.
#[root@container]

    createnew()
        {
        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@001-offerset-request.yaml" \
            --header 'Accept: application/yaml' \
            'http://127.0.0.1:8082/offersets' \
        > "002-offerset-response.yaml"

        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@003-accept-00-request.yaml" \
            --header 'Accept: application/yaml' \
            "$(yq '.offers[0].meta.url' '002-offerset-response.yaml')" \
        > "004-accept-00-response.yaml"
        }


    for x in {1..10}; do createnew; done


# -----------------------------------------------------
# Run PostgreSQL in a container.
#[user@desktop]

    podman run \
        --rm \
        --detach \
        --replace \
        --name postgresql \
        --publish 5432:5432 \
        --env "POSTGRES_DB=calycopis" \
        --env "POSTGRES_USER=albert" \
        --env "POSTGRES_PASSWORD=UVai0wie-wa9Eed4g" \
        docker.io/library/postgres:latest


    podman exec \
        --tty \
        --interactive \
        postgresql \
            bash

        psql --host localhost --username albert calycopis

    >   psql (18.1 (Debian 18.1-1.pgdg13+2))
    >   Type "help" for help.
    >   
    >   calycopis=#
    >   ....
    >   ....

    >   calycopis=# \db
    >         List of tablespaces
    >       Name    | Owner  | Location
    >   ------------+--------+----------
    >    pg_default | albert |
    >    pg_global  | albert |
    >   (2 rows)

    >   calycopis=# \dt
    >   Did not find any tables.


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

    >   ....
    >   ....
    >   org.hibernate.exception.JDBCConnectionException: unable to obtain isolated JDBC connection [Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.] [n/a]
    >   ....
    >   ....

    #
    # OK, here we go ...
    #


# -----------------------------------------------------
# Run our containers in a Podman Pod.
#[user@desktop]

    podman pod create \
        --name calycopis-pod

    source "${HOME:?}/calycopis.env"
    podman run \
        --rm \
        --tty \
        --interactive \
        --pod calycopis-pod \
        --expose 8082 \
        --name developer-tools \
        --volume "${TREBULA_CODE}:/trebula:rw,z" \
        --volume "${ISOBEON_CODE}:/isobeon:rw,z" \
        --volume "${CALYCOPIS_CODE}:/calycopis:rw,z" \
        --volume "${HOME}/.m2/repository:/root/.m2/repository:rw,z" \
        ghcr.io/ivoa/calycopis/developer-tools:2025.08.12 \
        bash

    >   ....
    >   ....


    podman run \
        --rm \
        --detach \
        --replace \
        --name postgresql \
        --pod calycopis-pod \
        --expose 5432 \
        --env "POSTGRES_DB=calycopis" \
        --env "POSTGRES_USER=albert" \
        --env "POSTGRES_PASSWORD=UVai0wie-wa9Eed4g" \
        docker.io/library/postgres:latest

    >   ....
    >   ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

        ....
        ....

    >   ....
    >   ....
    >   2025-12-04 18:40:01 ERROR main SpringApplication reportFailure() Application run failed
    >   org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'abstractProcessorServiceImpl.TransactionalInnerClass': Unsatisfied dependency expressed through field 'repository': Error creating bean with name 'abstractProcessorEntityRepository' defined in net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository defined in @EnableJpaRepositories declared on AmbleckApplication: Could not create query for public abstract java.util.UUID net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository.selectNextActive(java.util.UUID,java.util.List); Reason: Validation failed for query for method public abstract java.util.UUID net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository.selectNextActive(java.util.UUID,java.util.List)
    >   ....
    >   ....
    >   Caused by: org.springframework.data.repository.query.QueryCreationException: Could not create query for public abstract java.util.UUID net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository.selectNextActive(java.util.UUID,java.util.List); Reason: Validation failed for query for method public abstract java.util.UUID net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository.selectNextActive(java.util.UUID,java.util.List)
    >   ....
    >   ....
    >   Caused by: java.lang.IllegalArgumentException: Validation failed for query for method public abstract java.util.UUID net.ivoa.calycopis.functional.processing.AbstractProcessorEntityRepository.selectNextActive(java.util.UUID,java.util.List)
    >   ....
    >   ....
    >   Caused by: java.lang.IllegalArgumentException: org.hibernate.query.SemanticException: Cannot compare left expression of type 'java.time.OffsetDateTime' with right expression of type 'java.lang.Object'
    >   ....
    >   ....
    >   Caused by: org.hibernate.query.SemanticException: Cannot compare left expression of type 'java.time.OffsetDateTime' with right expression of type 'java.lang.Object'
    >   ....
    >   ....

    #
    # To start with, we shouldn't be using OffsetDateTime.
    # https://stackoverflow.com/questions/32437550/whats-the-difference-between-instant-and-localdatetime/32443004#32443004
    #

    #
    # We can tell the OpenAPI code generator which classes to use for dates and times.
    # https://www.baeldung.com/openapi-map-date-types#use-other-standard-date-classes
    #
    >     ....
    >     <configOptions>
    >         <java8>true</java8>
    >         <dateLibrary>custom</dateLibrary>
    >         <openApiNullable>false</openApiNullable>
    >         <interfaceOnly>true</interfaceOnly>
    >     </configOptions>
    >     <typeMappings>
    >       <typeMapping>DateTime=Instant</typeMapping>
    >       <typeMapping>Date=Date</typeMapping>
    >     </typeMappings>
    >     <importMappings>
    >         <importMapping>Instant=java.time.Instant</importMapping>
    >         <importMapping>Date=java.util.Date</importMapping>
    >     </importMappings>
    >     ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

    >   ....
    >   ....
    >   Caused by: org.hibernate.query.SemanticException: Cannot compare left expression of type 'java.time.OffsetDateTime' with right expression of type 'java.lang.Object'
    >   ....
    >   ....

        #
        # Found a JPA value for the current date and time.
        # Updated the query, and that part compiles OK.
        # https://www.objectdb.com/java/jpa/query/jpql/date#current_date_and_time
        #

    >   ....
    >   ....
    >   AND
    >       activation < CURRENT_TIMESTAMP
    >   ....


# -----------------------------------------------------
# Build the Java service API.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-openapi ; ./mvnw clean install ; popd

        ....
        ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

        ....
        ....




    >   ....
    >   2025-12-05 14:11:01 ERROR http-nio-8082-exec-1 [dispatcherServlet] log() Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception
    >       [Request processing failed: org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [
    >       ....
    >       ....
    >       ]] with root cause
    >   org.postgresql.util.PSQLException: ERROR: syntax error at or near "    "
    >     Position: 1739
    >   ....

    So ... Position: 1739
    That doesn't really help much.

            """
            WITH ExecutionBlocks AS
                (
                SELECT
                    SimpleExecutionSessions.phase AS BlockPhase,
                    ScheduledExecutionSessions.available_start_instant_seconds  / :blockstep AS BlockStart,
                    ScheduledExecutionSessions.available_duration_seconds / :blockstep AS BlockLength,
                    COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
                    COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
                FROM
                    SimpleExecutionSessions
                JOIN
                    ScheduledExecutionSessions
                ON
                    SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
                JOIN
                    AbstractComputeResources
                ON
                    AbstractComputeResources.session = SimpleExecutionSessions.uuid
                JOIN
                    SimpleComputeResources
                ON
                    SimpleComputeResources.uuid = AbstractComputeResources.uuid
                WHERE
                    SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
                ),
            AvailableBlocks AS
                (
                SELECT
                    StartRange.StartRow AS StartRow,
                    COUNT(ExecutionBlocks.BlockStart) AS RowCount,
                    (:totalcores  - IfNull(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
                    (:totalmemory - IfNull(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
                FROM
                    (
                    SELECT
                        x + :rangeoffset AS StartRow
                    FROM
                        SYSTEM_RANGE(:rangestart, :rangeend)
                    ) AS StartRange
                LEFT OUTER JOIN
                    ExecutionBlocks
                ON  (
                        (ExecutionBlocks.BlockStart <= StartRange.StartRow)
                        AND
                        ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
                        )
                GROUP BY
                    StartRange.StartRow
                ),
            ConsecutiveBlocks AS (
                SELECT
                    AvailableBlocks.StartRow,
                    (AvailableBlocks.StartRow + 1) -
                        (
                        ROW_NUMBER() OVER (
                            PARTITION BY (
                                AvailableBlocks.FreeCores  >= :mincores
                                AND
                                AvailableBlocks.FreeMemory >= :minmemory
                                )
                            ORDER BY AvailableBlocks.StartRow
                            )
                        ) AS BlockGroup,
                    FreeCores,
                    FreeMemory
                FROM
                    AvailableBlocks
                WHERE
                    AvailableBlocks.FreeCores  >= :mincores
                    AND
                    AvailableBlocks.FreeMemory >= :minmemory
                ),
            CombinedBlocks AS (
                SELECT
                    COUNT(*) AS BlockLength,
                    MIN(ConsecutiveBlocks.StartRow)   AS BlockStart,
                    MIN(ConsecutiveBlocks.FreeCores)  AS FreeCores,
                    MIN(ConsecutiveBlocks.FreeMemory) AS FreeMemory
                FROM
                    ConsecutiveBlocks
                WHERE
                    ConsecutiveBlocks.BlockGroup IS NOT NULL
                GROUP BY
                    ConsecutiveBlocks.BlockGroup
                HAVING
                    COUNT(*) >= :minblocklength
                ),
            SplitBlocks AS (
                SELECT
                    (CombinedBlocks.BlockStart + (:maxblocklength * (n - 1))) AS BlockStart,
                    LEAST(
                        :maxblocklength,
                        (CombinedBlocks.BlockLength - (:maxblocklength * (n - 1)))
                        ) AS BlockLength,
                    CombinedBlocks.FreeCores  AS FreeCores,
                    CombinedBlocks.FreeMemory AS FreeMemory
                FROM
                    CombinedBlocks,
                    (
                    SELECT
                        x AS n
                    FROM
                        SYSTEM_RANGE(1, :maxblocklength)
                    ) AS Numbers
                WHERE
                    (CombinedBlocks.BlockStart + (:maxblocklength * (n - 1))) < (BlockStart + BlockLength)
                ),
            MatchingBlocks AS (
                SELECT
                    AvailableBlocks.StartRow,
                    SplitBlocks.BlockStart,
                    SplitBlocks.BlockLength,
                    SplitBlocks.FreeCores,
                    SplitBlocks.FreeMemory
                FROM
                    AvailableBlocks
                JOIN
                    SplitBlocks
                WHERE
                    AvailableBlocks.StartRow >= SplitBlocks.BlockStart
                AND
                    AvailableBlocks.StartRow < (SplitBlocks.BlockStart + SplitBlocks.BlockLength)
                AND
                    SplitBlocks.BlockLength >= :minblocklength
                AND
                    SplitBlocks.BlockLength <= :maxblocklength
                ),
            GroupedBlocks AS (
                SELECT
                    MatchingBlocks.BlockStart,
                    MatchingBlocks.BlockLength,
                    MIN(MatchingBlocks.FreeCores)  AS FreeCores,
                    MIN(MatchingBlocks.FreeMemory) AS FreeMemory
                FROM
                    MatchingBlocks
                GROUP BY
                    MatchingBlocks.BlockStart,
                    MatchingBlocks.BlockLength
                ),
            ScaledBlocks AS (
                SELECT
                    GroupedBlocks.BlockStart,
                    GroupedBlocks.BlockLength,
                    LEAST(
                        :maxcores,
                        GroupedBlocks.FreeCores
                        ) AS BlockCores,
                    LEAST(
                        :maxmemory,
                        GroupedBlocks.FreeMemory
                        ) AS BlockMemory
                FROM
                    GroupedBlocks
                ),
            EarlyBlocks AS (
                SELECT
                    *
                FROM
                    ScaledBlocks
                ORDER BY
                    ScaledBlocks.BlockStart    ASC,
                    ScaledBlocks.BlockCores    DESC,
                    ScaledBlocks.BlockMemory   DESC,
                    ScaledBlocks.BlockLength   DESC
                LIMIT :querylimit
                ),
            HiMemBlocks AS (
                SELECT
                    *
                FROM
                    ScaledBlocks
                ORDER BY
                    ScaledBlocks.BlockMemory   DESC,
                    ScaledBlocks.BlockCores    DESC,
                    ScaledBlocks.BlockStart    ASC,
                    ScaledBlocks.BlockLength   DESC
                LIMIT :querylimit
                ),
            HiCpuBlocks AS (
                SELECT
                    *
                FROM
                    ScaledBlocks
                ORDER BY
                    ScaledBlocks.BlockCores    DESC,
                    ScaledBlocks.BlockMemory   DESC,
                    ScaledBlocks.BlockStart    ASC,
                    ScaledBlocks.BlockLength   DESC
                LIMIT :querylimit
                ),
            CombinedQuery AS (
                (
                SELECT
                    *
                FROM
                    EarlyBlocks
                )
            UNION
                (
                SELECT
                    *
                FROM
                    HiMemBlocks
                )
            UNION
                (
                SELECT
                    *
                FROM
                    HiCpuBlocks
                )
            )

            SELECT * FROM CombinedQuery

            """;

# -----------------------------------------------------
# Check what database tables we have.
#[root@developer-tools]
#

    podman exec -it \
        postgresql \
            bash

        psql --username albert --password  calycopis

            \db

    >         List of tablespaces
    >       Name    | Owner  | Location
    >   ------------+--------+----------
    >    pg_default | albert |
    >    pg_global  | albert |
    >   (2 rows)


            \dt
    >                       List of tables
    >    Schema |            Name            | Type  | Owner
    >   --------+----------------------------+-------+--------
    >    public | abstract_processors        | table | albert
    >    public | abstractcomputeresources   | table | albert
    >    public | abstractdataresources      | table | albert
    >    public | abstractexecutables        | table | albert
    >    public | abstractexecutionsessions  | table | albert
    >    public | abstractstorageresources   | table | albert
    >    public | abstractvolumemounts       | table | albert
    >    public | components                 | table | albert
    >    public | dockercontainers           | table | albert
    >    public | dockerenvironmentvariables | table | albert
    >    public | dockerexternaladdresses    | table | albert
    >    public | dockerimagelocations       | table | albert
    >    public | dockernetworkports         | table | albert
    >    public | ivoadataresources          | table | albert
    >    public | jupyternotebooks           | table | albert
    >    public | lifecyclecomponents        | table | albert
    >    public | messages                   | table | albert
    >    public | offersets                  | table | albert
    >    public | planningsequence           | table | albert
    >    public | planningsteps              | table | albert
    >    public | podmandockercontainers     | table | albert
    >    public | podmanjupyternotebooks     | table | albert
    >    public | s3dataresources            | table | albert
    >    public | scheduledexecutionsessions | table | albert
    >    public | sessionconnectors          | table | albert
    >    public | simplecomputeresources     | table | albert
    >    public | simpledataresources        | table | albert
    >    public | simpleexecutionsessions    | table | albert
    >    public | simplestorageresources     | table | albert
    >    public | simplevolumemounts         | table | albert
    >    public | skaodataresourcereplicas   | table | albert
    >    public | skaodataresources          | table | albert
    >    public | test_processors            | table | albert
    >    public | teststeps                  | table | albert
    >   (34 rows)


        #
        # Note that we are not using JPA to convert the query into the correct dialect.
        # There were issues with JPA, so we are using a JdbcTemplate and writing our own query.
        # Ideally we should go back and fix the issues with the JPA query generator.
        #


        #
        # Looking for differences between H2 and PostgreSQL.
        #
        # H2 SYSTEM_RANGE = PostgreSQL GENERATE_SERIES
        # https://github.com/jOOQ/jOOQ/issues/2892
        # https://www.postgresql.org/docs/current/functions-srf.html
        #



        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')

    >    blockphase | blockstart | blocklength | usedcores | usedmemory
    >   ------------+------------+-------------+-----------+------------
    >   (0 rows)


    WITH ExecutionBlocks AS
        (
        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
        )

    SELECT
        StartRange.StartRow AS StartRow,
        COUNT(ExecutionBlocks.BlockStart) AS RowCount,
        (32  - IfNull(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
        (34359738368 - IfNull(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
    FROM
        (
        SELECT
            generate_series + 29415773 AS StartRow
        FROM
             generate_series(1, 1440)
        ) AS StartRange
    LEFT OUTER JOIN
        ExecutionBlocks
    ON  (
            (ExecutionBlocks.BlockStart <= StartRange.StartRow)
        AND
            ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
        )
    GROUP BY
        StartRange.StartRow
    ;

    >   ERROR:  syntax error at or near "    "
    >   LINE 43:         AND

    #
    # It is objecting to the spaces before the AND in the LEFT OUTER JOIN .. ON criteria.
    # ... because they weren't spaces.
    # Replaced whatever was there with actual spaces and that part passes the validation.
    #
    # Moving on to the next problem.
    #

    >   ERROR:  function ifnull(numeric, integer) does not exist
    >   LINE 30:         (32  - IfNull(sum(ExecutionBlocks.UsedCores),  0)) A...
    >                           ^
    >   HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

    #
    # H2 IfNull is an alias for COALESCE
    # https://www.h2database.com/html/functions.html#coalesce
    #

    WITH ExecutionBlocks AS
        (
        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
        )

    SELECT
        StartRange.StartRow AS StartRow,
        COUNT(ExecutionBlocks.BlockStart) AS RowCount,
        (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
        (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
    FROM
        (
        SELECT
            generate_series + 29415773 AS StartRow
        FROM
             generate_series(1, 1440)
        ) AS StartRange
    LEFT OUTER JOIN
        ExecutionBlocks
    ON  (
            (ExecutionBlocks.BlockStart <= StartRange.StartRow)
        AND
            ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
        )
    GROUP BY
        StartRange.StartRow
    ;

    >   startrow | rowcount | freecores | freememory
    >   ----------+----------+-----------+-------------
    >    29415869 |        0 |        32 | 34359738368
    >    29416178 |        0 |        32 | 34359738368
    >    29416835 |        0 |        32 | 34359738368
    >    29416238 |        0 |        32 | 34359738368
    >    29416630 |        0 |        32 | 34359738368
    >    29417016 |        0 |        32 | 34359738368
    >    29417010 |        0 |        32 | 34359738368
    >    29415966 |        0 |        32 | 34359738368
    >    29416945 |        0 |        32 | 34359738368
    >    29416618 |        0 |        32 | 34359738368
    >    29416598 |        0 |        32 | 34359738368
    >    29416651 |        0 |        32 | 34359738368
    >    29415933 |        0 |        32 | 34359738368
    >   ....
    >   ....
    >    29416841 |        0 |        32 | 34359738368
    >    29416197 |        0 |        32 | 34359738368
    >    29416056 |        0 |        32 | 34359738368
    >   (1440 rows)

    #
    # Moving on to the next problem.
    #


    WITH ExecutionBlocks AS
        (
        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
        ),
    AvailableBlocks AS
        (
        SELECT
            StartRange.StartRow AS StartRow,
            COUNT(ExecutionBlocks.BlockStart) AS RowCount,
            (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
            (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
        FROM
            (
            SELECT
                generate_series + 29415773 AS StartRow
            FROM
                 generate_series(1, 1440)
            ) AS StartRange
        LEFT OUTER JOIN
            ExecutionBlocks
        ON  (
                (ExecutionBlocks.BlockStart <= StartRange.StartRow)
            AND
                ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
            )
        GROUP BY
            StartRange.StartRow
        ),
    ConsecutiveBlocks AS (
        SELECT
            AvailableBlocks.StartRow,
            (AvailableBlocks.StartRow + 1) -
                (
                ROW_NUMBER () OVER (
                    PARTITION BY (
                        AvailableBlocks.FreeCores  >= 1
                        AND
                        AvailableBlocks.FreeMemory >= 1
                        )
                    ORDER BY AvailableBlocks.StartRow
                    )
                ) AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocks
        WHERE
            AvailableBlocks.FreeCores  >= 1
            AND
            AvailableBlocks.FreeMemory >= 1
        )
    SELECT * FROM ConsecutiveBlocks
    ;

    >   ERROR:  syntax error at or near "ROW_NUMBER"
    >   LINE 55:                 ROW_NUMBER() OVER (


    Removed "(AvailableBlocks.StartRow + 1) -" and we get a different error ..

    >   ERROR:  syntax error at or near "("
    >   LINE 53:             ROW_NUMBER() OVER (


    WITH ExecutionBlocks AS
        (
        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
        ),
    AvailableBlocks AS
        (
        SELECT
            StartRange.StartRow AS StartRow,
            COUNT(ExecutionBlocks.BlockStart) AS RowCount,
            (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
            (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
        FROM
            (
            SELECT
                generate_series + 29415773 AS StartRow
            FROM
                 generate_series(1, 1440)
            ) AS StartRange
        LEFT OUTER JOIN
            ExecutionBlocks
        ON  (
                (ExecutionBlocks.BlockStart <= StartRange.StartRow)
            AND
                ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
            )
        GROUP BY
            StartRange.StartRow
        ),
    ConsecutiveBlocks AS (
        SELECT
            AvailableBlocks.StartRow,
            ROW_NUMBER() OVER (
                PARTITION BY (
                    AvailableBlocks.FreeCores  >= 1
                    AND
                    AvailableBlocks.FreeMemory >= 1
                    )
                ORDER BY
                    AvailableBlocks.StartRow
                ) AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocks
        WHERE
            AvailableBlocks.FreeCores  >= 1
            AND
            AvailableBlocks.FreeMemory >= 1
        )
    SELECT * FROM ConsecutiveBlocks
    ;

    >   ERROR:  syntax error at or near "("
    >   LINE 53:             ROW_NUMBER() OVER (


    #
    # Let's select some data into a temp table to make it easier to debug ..
    #

    WITH ExecutionBlocks AS
        (
        SELECT
            SimpleExecutionSessions.phase AS BlockPhase,
            ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
            ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
            COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
            COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
        FROM
            SimpleExecutionSessions
        JOIN
            ScheduledExecutionSessions
        ON
            SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
        JOIN
            AbstractComputeResources
        ON
            AbstractComputeResources.session = SimpleExecutionSessions.uuid
        JOIN
            SimpleComputeResources
        ON
            SimpleComputeResources.uuid = AbstractComputeResources.uuid
        WHERE
            SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
        ),
    AvailableBlocks AS
        (
        SELECT
            StartRange.StartRow AS StartRow,
            COUNT(ExecutionBlocks.BlockStart) AS RowCount,
            (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
            (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
        FROM
            (
            SELECT
                generate_series + 29415773 AS StartRow
            FROM
                 generate_series(1, 1440)
            ) AS StartRange
        LEFT OUTER JOIN
            ExecutionBlocks
        ON  (
                (ExecutionBlocks.BlockStart <= StartRange.StartRow)
            AND
                ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
            )
        GROUP BY
            StartRange.StartRow
        )
    SELECT * INTO AvailableBlocksTemp FROM AvailableBlocks
    ;

    >   SELECT 1440

    #
    # Now we can experiment with the ConsecutiveBlocks query.
    #

        SELECT
            AvailableBlocksTemp.StartRow,
            (AvailableBlocksTemp.StartRow + 1) -
                (
                ROW_NUMBER () OVER (
                    PARTITION BY (
                        AvailableBlocksTemp.FreeCores  >= 1
                        AND
                        AvailableBlocksTemp.FreeMemory >= 1
                        )
                    ORDER BY AvailableBlocksTemp.StartRow
                    )
                ) AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >   ERROR:  syntax error at or near "ROW_NUMBER"
    >   LINE 5:                 ROW_NUMBER () OVER (



        SELECT
            ROW_NUMBER () OVER (
                PARTITION BY (
                    AvailableBlocksTemp.FreeCores  >= 1
                    AND
                    AvailableBlocksTemp.FreeMemory >= 1
                    )
                ORDER BY AvailableBlocksTemp.StartRow
                )
            ) AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >   ERROR:  syntax error at or near "("
    >   LINE 2:             ROW_NUMBER () OVER (


        SELECT
            ROW_NUMBER () OVER () AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >   ERROR:  syntax error at or near "("
    >   LINE 2:             ROW_NUMBER () OVER () AS BlockGroup,


        SELECT
            ROW_NUMBER() OVER () AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >   ERROR:  syntax error at or near "("
    >   LINE 2:             ROW_NUMBER() AS BlockGroup,


        SELECT
            ROW_NUMBER() OVER () AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >   ERROR:  syntax error at or near "("
    >   LINE 2:             ROW_NUMBER() AS BlockGroup,


        SELECT ROW_NUMBER() OVER () AS BlockGroup,
            FreeCores,
            FreeMemory
        FROM
            AvailableBlocksTemp
        WHERE
            AvailableBlocksTemp.FreeCores  >= 1
            AND
            AvailableBlocksTemp.FreeMemory >= 1
        ;

    >    blockgroup | freecores | freememory
    >   ------------+-----------+-------------
    >             1 |        32 | 34359738368
    >             2 |        32 | 34359738368
    >             3 |        32 | 34359738368
    >           ....
    >           ....
    >          1438 |        32 | 34359738368
    >          1439 |        32 | 34359738368
    >          1440 |        32 | 34359738368
    >   (1440 rows)

        #
        # It was a problem with white spaces (again) !!
        #

        #
        # Looking at a hex dump of the text file, it contains lots of C2 A0 pairs,
        # which correspond to the UTF-8 chatacyer for a non-breaking space.
        # https://en.wikipedia.org/wiki/Non-breaking_space#Encodings
        #

    hexdump -C ComputeResourceOfferFactoryImpl.java

    >   ....
    >   000025b0  20 20 20 20 20 20 20 20  53 45 4c 45 43 54 0a 20  |        SELECT. |
    >   000025c0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   000025d0  20 20 20 41 76 61 69 6c  61 62 6c 65 42 6c 6f 63  |   AvailableBloc|
    >   000025e0  6b 73 2e 53 74 61 72 74  52 6f 77 2c 0a 20 20 20  |ks.StartRow,.   |
    >   000025f0  20 20 20 20 20 20 20 20  20 c2 a0 c2 a0 c2 a0 c2  |         .......|
    >   00002600  a0 c2 a0 c2 a0 c2 a0 c2  a0 28 41 76 61 69 6c 61  |.........(Availa|
    >   00002610  62 6c 65 42 6c 6f 63 6b  73 2e 53 74 61 72 74 52  |bleBlocks.StartR|
    >   00002620  6f 77 20 2b 20 31 29 20  2d 0a 20 20 20 20 20 20  |ow + 1) -.      |
    >   00002630  20 20 20 20 20 20 c2 a0  c2 a0 c2 a0 c2 a0 c2 a0  |      ..........|
    >   00002640  c2 a0 c2 a0 c2 a0 20 20  20 20 28 0a 20 20 20 20  |......    (.    |
    >   00002650  20 20 20 20 20 20 20 20  c2 a0 c2 a0 c2 a0 c2 a0  |        ........|
    >   00002660  c2 a0 c2 a0 c2 a0 c2 a0  20 20 20 20 52 4f 57 5f  |........    ROW_|
    >   00002670  4e 55 4d 42 45 52 28 29  20 4f 56 45 52 20 28 0a  |NUMBER() OVER (.|
    >   00002680  20 20 20 20 20 20 20 20  20 20 20 20 c2 a0 c2 a0  |            ....|
    >   00002690  c2 a0 c2 a0 c2 a0 c2 a0  c2 a0 c2 a0 20 20 20 20  |............    |
    >   000026a0  20 20 20 20 50 41 52 54  49 54 49 4f 4e 20 42 59  |    PARTITION BY|
    >   000026b0  20 28 0a 20 20 20 20 20  20 20 20 20 20 20 20 c2  | (.            .|
    >   000026c0  a0 c2 a0 c2 a0 c2 a0 c2  a0 c2 a0 c2 a0 c2 a0 20  |............... |
    >   000026d0  20 20 20 20 20 20 20 20  20 20 20 41 76 61 69 6c  |           Avail|
    >   000026e0  61 62 6c 65 42 6c 6f 63  6b 73 2e 46 72 65 65 43  |ableBlocks.FreeC|
    >   000026f0  6f 72 65 73 20 20 3e 3d  20 3a 6d 69 6e 63 6f 72  |ores  >= :mincor|
    >   00002700  65 73 0a 20 20 20 20 20  20 20 20 20 20 20 20 c2  |es.            .|
    >   00002710  a0 c2 a0 c2 a0 c2 a0 c2  a0 c2 a0 c2 a0 c2 a0 20  |............... |
    >   00002720  20 20 20 20 20 20 20 20  20 20 20 41 4e 44 0a 20  |           AND. |
    >   00002730  20 20 20 20 20 20 20 20  20 20 20 c2 a0 c2 a0 c2  |           .....|
    >   00002740  a0 c2 a0 c2 a0 c2 a0 c2  a0 c2 a0 20 20 20 20 20  |...........     |
    >   00002750  20 20 20 20 20 20 20 41  76 61 69 6c 61 62 6c 65  |       Available|
    >   00002760  42 6c 6f 63 6b 73 2e 46  72 65 65 4d 65 6d 6f 72  |Blocks.FreeMemor|
    >   00002770  79 20 3e 3d 20 3a 6d 69  6e 6d 65 6d 6f 72 79 0a  |y >= :minmemory.|
    >   00002780  20 20 20 20 20 20 20 20  20 20 20 20 c2 a0 c2 a0  |            ....|
    >   00002790  c2 a0 c2 a0 c2 a0 c2 a0  c2 a0 c2 a0 20 20 20 20  |............    |
    >   000027a0  20 20 20 20 20 20 20 20  29 0a 20 20 20 20 20 20  |        ).      |
    >   000027b0  20 20 20 20 20 20 c2 a0  c2 a0 c2 a0 c2 a0 c2 a0  |      ..........|
    >   000027c0  c2 a0 c2 a0 c2 a0 20 20  20 20 20 20 20 20 4f 52  |......        OR|
    >   000027d0  44 45 52 20 42 59 20 41  76 61 69 6c 61 62 6c 65  |DER BY Available|
    >   000027e0  42 6c 6f 63 6b 73 2e 53  74 61 72 74 52 6f 77 0a  |Blocks.StartRow.|
    >   000027f0  20 20 20 20 20 20 20 20  20 20 20 20 c2 a0 c2 a0  |            ....|
    >   00002800  c2 a0 c2 a0 c2 a0 c2 a0  c2 a0 c2 a0 20 20 20 20  |............    |
    >   00002810  20 20 20 20 29 0a 20 20  20 20 20 20 20 20 20 20  |    ).          |
    >   00002820  20 20 c2 a0 c2 a0 c2 a0  c2 a0 c2 a0 c2 a0 c2 a0  |  ..............|
    >   00002830  c2 a0 20 20 20 20 29 20  41 53 20 42 6c 6f 63 6b  |..    ) AS Block|
    >   00002840  47 72 6f 75 70 2c 0a 20  20 20 20 20 20 20 20 20  |Group,.         |
    >   ....

        #
        # Useful `sed` expression to replace them
        # https://www.scivision.dev/hex-code-c2a0-non-breaking-space-markdown/

        sed -i 's/\xC2\xA0/ /g' ComputeResourceOfferFactoryImpl.java

        hexdump -C ComputeResourceOfferFactoryImpl.java

    >   ....
    >   000025b0  20 20 20 20 20 20 20 20  53 45 4c 45 43 54 0a 20  |        SELECT. |
    >   000025c0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   000025d0  20 20 20 41 76 61 69 6c  61 62 6c 65 42 6c 6f 63  |   AvailableBloc|
    >   000025e0  6b 73 2e 53 74 61 72 74  52 6f 77 2c 0a 20 20 20  |ks.StartRow,.   |
    >   000025f0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002600  20 28 41 76 61 69 6c 61  62 6c 65 42 6c 6f 63 6b  | (AvailableBlock|
    >   00002610  73 2e 53 74 61 72 74 52  6f 77 20 2b 20 31 29 20  |s.StartRow + 1) |
    >   00002620  2d 0a 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |-.              |
    >   00002630  20 20 20 20 20 20 20 20  20 20 28 0a 20 20 20 20  |          (.    |
    >   00002640  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002650  20 20 20 20 52 4f 57 5f  4e 55 4d 42 45 52 28 29  |    ROW_NUMBER()|
    >   00002660  20 4f 56 45 52 20 28 0a  20 20 20 20 20 20 20 20  | OVER (.        |
    >   00002670  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002680  20 20 20 20 50 41 52 54  49 54 49 4f 4e 20 42 59  |    PARTITION BY|
    >   00002690  20 28 0a 20 20 20 20 20  20 20 20 20 20 20 20 20  | (.             |
    >   000026a0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   000026b0  20 20 20 41 76 61 69 6c  61 62 6c 65 42 6c 6f 63  |   AvailableBloc|
    >   000026c0  6b 73 2e 46 72 65 65 43  6f 72 65 73 20 20 3e 3d  |ks.FreeCores  >=|
    >   000026d0  20 3a 6d 69 6e 63 6f 72  65 73 0a 20 20 20 20 20  | :mincores.     |
    >   000026e0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   000026f0  20 20 20 20 20 20 20 20  20 20 20 41 4e 44 0a 20  |           AND. |
    >   00002700  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002710  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 41  |               A|
    >   00002720  76 61 69 6c 61 62 6c 65  42 6c 6f 63 6b 73 2e 46  |vailableBlocks.F|
    >   00002730  72 65 65 4d 65 6d 6f 72  79 20 3e 3d 20 3a 6d 69  |reeMemory >= :mi|
    >   00002740  6e 6d 65 6d 6f 72 79 0a  20 20 20 20 20 20 20 20  |nmemory.        |
    >   00002750  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002760  20 20 20 20 20 20 20 20  29 0a 20 20 20 20 20 20  |        ).      |
    >   00002770  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   00002780  20 20 20 20 20 20 4f 52  44 45 52 20 42 59 20 41  |      ORDER BY A|
    >   00002790  76 61 69 6c 61 62 6c 65  42 6c 6f 63 6b 73 2e 53  |vailableBlocks.S|
    >   000027a0  74 61 72 74 52 6f 77 0a  20 20 20 20 20 20 20 20  |tartRow.        |
    >   000027b0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
    >   000027c0  20 20 20 20 29 0a 20 20  20 20 20 20 20 20 20 20  |    ).          |
    >   000027d0  20 20 20 20 20 20 20 20  20 20 20 20 20 20 29 20  |              ) |
    >   000027e0  41 53 20 42 6c 6f 63 6b  47 72 6f 75 70 2c 0a 20  |AS BlockGroup,. |
    >   ....


# -----------------------------------------------------
# Build and run the Java service.
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd


    >   ....
    >   2025-12-05 17:42:10 ERROR http-nio-8082-exec-1 [dispatcherServlet] log() Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [
    >   WITH ExecutionBlocks AS
    >       (
    >       SELECT
    >           SimpleExecutionSessions.phase AS BlockPhase,
    >           ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
    >           ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
    >           COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
    >           COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
    >       FROM
    >           SimpleExecutionSessions
    >       JOIN
    >           ScheduledExecutionSessions
    >       ON
    >           SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
    >       JOIN
    >           AbstractComputeResources
    >       ON
    >           AbstractComputeResources.session = SimpleExecutionSessions.uuid
    >       JOIN
    >           SimpleComputeResources
    >       ON
    >           SimpleComputeResources.uuid = AbstractComputeResources.uuid
    >       WHERE
    >           SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')
    >       ),
    >   AvailableBlocks AS
    >       (
    >       SELECT
    >           StartRange.StartRow AS StartRow,
    >           COUNT(ExecutionBlocks.BlockStart) AS RowCount,
    >           (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
    >           (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
    >       FROM
    >           (
    >           SELECT
    >               generate_series + 29415942 AS StartRow
    >           FROM
    >                generate_series(1, 1440)
    >           ) AS StartRange
    >       LEFT OUTER JOIN
    >           ExecutionBlocks
    >       ON  (
    >               (ExecutionBlocks.BlockStart <= StartRange.StartRow)
    >           AND
    >               ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
    >           )
    >       GROUP BY
    >           StartRange.StartRow
    >       ),
    >   ConsecutiveBlocks AS (
    >       SELECT
    >           AvailableBlocks.StartRow,
    >           (AvailableBlocks.StartRow + 1) -
    >               (
    >               ROW_NUMBER() OVER (
    >                   PARTITION BY (
    >                       AvailableBlocks.FreeCores  >= 1
    >                       AND
    >                       AvailableBlocks.FreeMemory >= 1
    >                       )
    >                   ORDER BY AvailableBlocks.StartRow
    >                   )
    >               ) AS BlockGroup,
    >           FreeCores,
    >           FreeMemory
    >       FROM
    >           AvailableBlocks
    >       WHERE
    >           AvailableBlocks.FreeCores  >= 1
    >           AND
    >           AvailableBlocks.FreeMemory >= 1
    >       ),
    >   CombinedBlocks AS (
    >       SELECT
    >           COUNT(*) AS BlockLength,
    >           MIN(ConsecutiveBlocks.StartRow)   AS BlockStart,
    >           MIN(ConsecutiveBlocks.FreeCores)  AS FreeCores,
    >           MIN(ConsecutiveBlocks.FreeMemory) AS FreeMemory
    >       FROM
    >           ConsecutiveBlocks
    >       WHERE
    >           ConsecutiveBlocks.BlockGroup IS NOT NULL
    >       GROUP BY
    >           ConsecutiveBlocks.BlockGroup
    >       HAVING
    >           COUNT(*) >= 60
    >       ),
    >   SplitBlocks AS (
    >       SELECT
    >           (CombinedBlocks.BlockStart + (120 * (n - 1))) AS BlockStart,
    >           LEAST(
    >               120,
    >               (CombinedBlocks.BlockLength - (120 * (n - 1)))
    >               ) AS BlockLength,
    >           CombinedBlocks.FreeCores  AS FreeCores,
    >           CombinedBlocks.FreeMemory AS FreeMemory
    >       FROM
    >           CombinedBlocks,
    >           (
    >           SELECT
    >               x AS n
    >           FROM
    >               SYSTEM_RANGE(1, 120)
    >           ) AS Numbers
    >       WHERE
    >           (CombinedBlocks.BlockStart + (120 * (n - 1))) < (BlockStart + BlockLength)
    >       ),
    >   MatchingBlocks AS (
    >       SELECT
    >           AvailableBlocks.StartRow,
    >           SplitBlocks.BlockStart,
    >           SplitBlocks.BlockLength,
    >           SplitBlocks.FreeCores,
    >           SplitBlocks.FreeMemory
    >       FROM
    >           AvailableBlocks
    >       JOIN
    >           SplitBlocks
    >       WHERE
    >           AvailableBlocks.StartRow >= SplitBlocks.BlockStart
    >       AND
    >           AvailableBlocks.StartRow < (SplitBlocks.BlockStart + SplitBlocks.BlockLength)
    >       AND
    >           SplitBlocks.BlockLength >= 60
    >       AND
    >           SplitBlocks.BlockLength <= 120
    >       ),
    >   GroupedBlocks AS (
    >       SELECT
    >           MatchingBlocks.BlockStart,
    >           MatchingBlocks.BlockLength,
    >           MIN(MatchingBlocks.FreeCores)  AS FreeCores,
    >           MIN(MatchingBlocks.FreeMemory) AS FreeMemory
    >       FROM
    >           MatchingBlocks
    >       GROUP BY
    >           MatchingBlocks.BlockStart,
    >           MatchingBlocks.BlockLength
    >       ),
    >   ScaledBlocks AS (
    >       SELECT
    >           GroupedBlocks.BlockStart,
    >           GroupedBlocks.BlockLength,
    >           LEAST(
    >               2,
    >               GroupedBlocks.FreeCores
    >               ) AS BlockCores,
    >           LEAST(
    >               2,
    >               GroupedBlocks.FreeMemory
    >               ) AS BlockMemory
    >       FROM
    >           GroupedBlocks
    >       ),
    >   EarlyBlocks AS (
    >       SELECT
    >           *
    >       FROM
    >           ScaledBlocks
    >       ORDER BY
    >           ScaledBlocks.BlockStart    ASC,
    >           ScaledBlocks.BlockCores    DESC,
    >           ScaledBlocks.BlockMemory   DESC,
    >           ScaledBlocks.BlockLength   DESC
    >       LIMIT 4
    >       ),
    >   HiMemBlocks AS (
    >       SELECT
    >           *
    >       FROM
    >           ScaledBlocks
    >       ORDER BY
    >           ScaledBlocks.BlockMemory   DESC,
    >           ScaledBlocks.BlockCores    DESC,
    >           ScaledBlocks.BlockStart    ASC,
    >           ScaledBlocks.BlockLength   DESC
    >       LIMIT 4
    >       ),
    >   HiCpuBlocks AS (
    >       SELECT
    >           *
    >       FROM
    >           ScaledBlocks
    >       ORDER BY
    >           ScaledBlocks.BlockCores    DESC,
    >           ScaledBlocks.BlockMemory   DESC,
    >           ScaledBlocks.BlockStart    ASC,
    >           ScaledBlocks.BlockLength   DESC
    >       LIMIT 4
    >       ),
    >   CombinedQuery AS (
    >       (
    >       SELECT
    >           *
    >       FROM
    >           EarlyBlocks
    >       )
    >   UNION
    >       (
    >       SELECT
    >           *
    >       FROM
    >           HiMemBlocks
    >       )
    >   UNION
    >       (
    >       SELECT
    >           *
    >       FROM
    >           HiCpuBlocks
    >       )
    >   )
    >   
    >   SELECT * FROM CombinedQuery
    >   
    >   ]] with root cause
    >   org.postgresql.util.PSQLException: ERROR: syntax error at or near "WHERE"
    >     Position: 3593


    #
    # Put the same query into psql and we get a slightly more useful error.
    #

    >   ....
    >   ....
    >   ERROR:  syntax error at or near "WHERE"
    >   LINE 119:     WHERE


    #
    # Line 119 is the where clause of MatchingBlocks
    #

    >   ....
    >   MatchingBlocks AS (
    >       SELECT
    >           AvailableBlocks.StartRow,
    >           SplitBlocks.BlockStart,
    >           SplitBlocks.BlockLength,
    >           SplitBlocks.FreeCores,
    >           SplitBlocks.FreeMemory
    >       FROM
    >           AvailableBlocks
    >       JOIN
    >           SplitBlocks
    >       WHERE
    >           AvailableBlocks.StartRow >= SplitBlocks.BlockStart
    >       AND
    >           AvailableBlocks.StartRow < (SplitBlocks.BlockStart + SplitBlocks.BlockLength)
    >       AND
    >           SplitBlocks.BlockLength >= 60
    >       AND
    >           SplitBlocks.BlockLength <= 120
    >       ),
    >   ....


    #
    # Probably because we have a JOIN and no ON.
    #

    >   ....
    >                   FROM
    >                       AvailableBlocks
    >                   JOIN
    >                       SplitBlocks
    >                   WHERE
    >   ....





    SELECT
        SimpleExecutionSessions.phase AS BlockPhase,
        ScheduledExecutionSessions.available_start_instant_seconds  / 60 AS BlockStart,
        ScheduledExecutionSessions.available_duration_seconds / 60 AS BlockLength,
        COALESCE(SimpleComputeResources.maxofferedcores,  SimpleComputeResources.maxrequestedcores)  AS UsedCores,
        COALESCE(SimpleComputeResources.maxofferedmemory, SimpleComputeResources.maxrequestedmemory) AS UsedMemory
    INTO
        ExecutionBlocks
    FROM
        SimpleExecutionSessions
    JOIN
        ScheduledExecutionSessions
    ON
        SimpleExecutionSessions.uuid = ScheduledExecutionSessions.uuid
    JOIN
        AbstractComputeResources
    ON
        AbstractComputeResources.session = SimpleExecutionSessions.uuid
    JOIN
        SimpleComputeResources
    ON
        SimpleComputeResources.uuid = AbstractComputeResources.uuid
    WHERE
        SimpleExecutionSessions.phase IN ('OFFERED', 'PREPARING', 'WAITING', 'RUNNING', 'RELEASING')


    SELECT * FROM ExecutionBlocks ;

    >    blockphase | blockstart | blocklength | usedcores | usedmemory
    >   ------------+------------+-------------+-----------+------------
    >   (0 rows)


    SELECT
        StartRange.StartRow AS StartRow,
        COUNT(ExecutionBlocks.BlockStart) AS RowCount,
        (32  - COALESCE(sum(ExecutionBlocks.UsedCores),  0)) AS FreeCores,
        (34359738368 - COALESCE(sum(ExecutionBlocks.UsedMemory), 0)) AS FreeMemory
    INTO
        AvailableBlocks
    FROM
        (
        SELECT
            generate_series + 29415942 AS StartRow
        FROM
             generate_series(1, 1440)
        ) AS StartRange
    LEFT OUTER JOIN
        ExecutionBlocks
    ON  (
            (ExecutionBlocks.BlockStart <= StartRange.StartRow)
        AND
            ((ExecutionBlocks.BlockStart + ExecutionBlocks.BlockLength) > StartRange.StartRow)
        )
    GROUP BY
        StartRange.StartRow
    ;

    SELECT * FROM AvailableBlocks ;

    >    startrow | rowcount | freecores | freememory
    >   ----------+----------+-----------+-------------
    >    29416178 |        0 |        32 | 34359738368
    >    29416835 |        0 |        32 | 34359738368
    >    29416238 |        0 |        32 | 34359738368
    >   ....
    >   ....
    >    29416841 |        0 |        32 | 34359738368
    >    29416197 |        0 |        32 | 34359738368
    >    29416056 |        0 |        32 | 34359738368
    >   (1440 rows)


    SELECT
        AvailableBlocks.StartRow,
        (AvailableBlocks.StartRow + 1) -
            (
            ROW_NUMBER() OVER (
                PARTITION BY (
                    AvailableBlocks.FreeCores  >= 1
                    AND
                    AvailableBlocks.FreeMemory >= 1
                    )
                ORDER BY AvailableBlocks.StartRow
                )
            ) AS BlockGroup,
        FreeCores,
        FreeMemory
    INTO
        ConsecutiveBlocks
    FROM
        AvailableBlocks
    WHERE
        AvailableBlocks.FreeCores  >= 1
        AND
        AvailableBlocks.FreeMemory >= 1
    ;

    SELECT * FROM ConsecutiveBlocks ;

    >    startrow | blockgroup | freecores | freememory
    >   ----------+------------+-----------+-------------
    >    29415943 |   29415943 |        32 | 34359738368
    >    29415944 |   29415943 |        32 | 34359738368
    >    29415945 |   29415943 |        32 | 34359738368
    >   ....
    >   ....
    >    29417380 |   29415943 |        32 | 34359738368
    >    29417381 |   29415943 |        32 | 34359738368
    >    29417382 |   29415943 |        32 | 34359738368
    >   (1440 rows)


    SELECT
        COUNT(*) AS BlockLength,
        MIN(ConsecutiveBlocks.StartRow)   AS BlockStart,
        MIN(ConsecutiveBlocks.FreeCores)  AS FreeCores,
        MIN(ConsecutiveBlocks.FreeMemory) AS FreeMemory
    INTO
        CombinedBlocks
    FROM
        ConsecutiveBlocks
    WHERE
        ConsecutiveBlocks.BlockGroup IS NOT NULL
    GROUP BY
        ConsecutiveBlocks.BlockGroup
    HAVING
        COUNT(*) >= 60
    ;

    SELECT * FROM CombinedBlocks ;

    >    blocklength | blockstart | freecores | freememory
    >   -------------+------------+-----------+-------------
    >           1440 |   29415943 |        32 | 34359738368


    SELECT
        (CombinedBlocks.BlockStart + (120 * (n - 1))) AS BlockStart,
        LEAST(
            120,
            (CombinedBlocks.BlockLength - (120 * (n - 1)))
            ) AS BlockLength,
        CombinedBlocks.FreeCores  AS FreeCores,
        CombinedBlocks.FreeMemory AS FreeMemory
    INTO
        SplitBlocks
    FROM
        CombinedBlocks,
        (
        SELECT
            generate_series AS n
        FROM
            generate_series(1, 120)
        ) AS Numbers
    WHERE
        (CombinedBlocks.BlockStart + (120 * (n - 1))) < (BlockStart + BlockLength)
    ;

    SELECT * FROM SplitBlocks ;

    >   SELECT 12
    >    blockstart | blocklength | freecores | freememory
    >   ------------+-------------+-----------+-------------
    >      29415943 |         120 |        32 | 34359738368
    >      29416063 |         120 |        32 | 34359738368
    >      29416183 |         120 |        32 | 34359738368
    >      29416303 |         120 |        32 | 34359738368
    >      29416423 |         120 |        32 | 34359738368
    >      29416543 |         120 |        32 | 34359738368
    >      29416663 |         120 |        32 | 34359738368
    >      29416783 |         120 |        32 | 34359738368
    >      29416903 |         120 |        32 | 34359738368
    >      29417023 |         120 |        32 | 34359738368
    >      29417143 |         120 |        32 | 34359738368
    >      29417263 |         120 |        32 | 34359738368
    >   (12 rows)


    SELECT
        AvailableBlocks.StartRow,
        SplitBlocks.BlockStart,
        SplitBlocks.BlockLength,
        SplitBlocks.FreeCores,
        SplitBlocks.FreeMemory
    INTO
        MatchingBlocks
    FROM
        AvailableBlocks
    JOIN
        SplitBlocks
    WHERE
        AvailableBlocks.StartRow >= SplitBlocks.BlockStart
    AND
        AvailableBlocks.StartRow < (SplitBlocks.BlockStart + SplitBlocks.BlockLength)
    AND
        SplitBlocks.BlockLength >= 60
    AND
        SplitBlocks.BlockLength <= 120
    ;

    >   ERROR:  syntax error at or near "WHERE"
    >   LINE 13:     WHERE

    #
    # Looks like H2 interprets a JOIN with no ON as a CROSS JOIN.
    #

    SELECT
        AvailableBlocks.StartRow,
        SplitBlocks.BlockStart,
        SplitBlocks.BlockLength,
        SplitBlocks.FreeCores,
        SplitBlocks.FreeMemory
    INTO
        MatchingBlocks
    FROM
        AvailableBlocks
    CROSS JOIN
        SplitBlocks
    WHERE
        AvailableBlocks.StartRow >= SplitBlocks.BlockStart
    AND
        AvailableBlocks.StartRow < (SplitBlocks.BlockStart + SplitBlocks.BlockLength)
    AND
        SplitBlocks.BlockLength >= 60
    AND
        SplitBlocks.BlockLength <= 120
    ;

    SELECT * FROM MatchingBlocks ;

    >    startrow | blockstart | blocklength | freecores | freememory
    >   ----------+------------+-------------+-----------+-------------
    >    29416178 |   29416063 |         120 |        32 | 34359738368
    >    29416835 |   29416783 |         120 |        32 | 34359738368
    >    29416238 |   29416183 |         120 |        32 | 34359738368
    >   ....
    >   ....
    >    29416841 |   29416783 |         120 |        32 | 34359738368
    >    29416197 |   29416183 |         120 |        32 | 34359738368
    >    29416056 |   29415943 |         120 |        32 | 34359738368
    >   (1440 rows)

    SELECT
        MatchingBlocks.BlockStart,
        MatchingBlocks.BlockLength,
        MIN(MatchingBlocks.FreeCores)  AS FreeCores,
        MIN(MatchingBlocks.FreeMemory) AS FreeMemory
    INTO
        GroupedBlocks
    FROM
        MatchingBlocks
    GROUP BY
        MatchingBlocks.BlockStart,
        MatchingBlocks.BlockLength
    ;

    SELECT * FROM GroupedBlocks ;

    >    blockstart | blocklength | freecores | freememory
    >   ------------+-------------+-----------+-------------
    >      29416423 |         120 |        32 | 34359738368
    >      29416663 |         120 |        32 | 34359738368
    >      29415943 |         120 |        32 | 34359738368
    >      29416183 |         120 |        32 | 34359738368
    >      29417143 |         120 |        32 | 34359738368
    >      29417023 |         120 |        32 | 34359738368
    >      29416783 |         120 |        32 | 34359738368
    >      29417263 |         120 |        32 | 34359738368
    >      29416063 |         120 |        32 | 34359738368
    >      29416903 |         120 |        32 | 34359738368
    >      29416303 |         120 |        32 | 34359738368
    >      29416543 |         120 |        32 | 34359738368
    >   (12 rows)


    SELECT
        GroupedBlocks.BlockStart,
        GroupedBlocks.BlockLength,
        LEAST(
            2,
            GroupedBlocks.FreeCores
            ) AS BlockCores,
        LEAST(
            2,
            GroupedBlocks.FreeMemory
            ) AS BlockMemory
    INTO
        ScaledBlocks
    FROM
        GroupedBlocks
    ;

    SELECT * FROM ScaledBlocks ;

    >    blockstart | blocklength | blockcores | blockmemory
    >   ------------+-------------+------------+-------------
    >      29416423 |         120 |          2 |           2
    >      29416663 |         120 |          2 |           2
    >      29415943 |         120 |          2 |           2
    >      29416183 |         120 |          2 |           2
    >      29417143 |         120 |          2 |           2
    >      29417023 |         120 |          2 |           2
    >      29416783 |         120 |          2 |           2
    >      29417263 |         120 |          2 |           2
    >      29416063 |         120 |          2 |           2
    >      29416903 |         120 |          2 |           2
    >      29416303 |         120 |          2 |           2
    >      29416543 |         120 |          2 |           2
    >   (12 rows)


    SELECT
        *
    INTO
        EarlyBlocks
    FROM
        ScaledBlocks
    ORDER BY
        ScaledBlocks.BlockStart    ASC,
        ScaledBlocks.BlockCores    DESC,
        ScaledBlocks.BlockMemory   DESC,
        ScaledBlocks.BlockLength   DESC
    LIMIT 4
    ;

    SELECT * FROM EarlyBlocks ;

    >    blockstart | blocklength | blockcores | blockmemory
    >   ------------+-------------+------------+-------------
    >      29415943 |         120 |          2 |           2
    >      29416063 |         120 |          2 |           2
    >      29416183 |         120 |          2 |           2
    >      29416303 |         120 |          2 |           2
    >   (4 rows)


    SELECT
        *
    INTO
        HiMemBlocks
    FROM
        ScaledBlocks
    ORDER BY
        ScaledBlocks.BlockMemory   DESC,
        ScaledBlocks.BlockCores    DESC,
        ScaledBlocks.BlockStart    ASC,
        ScaledBlocks.BlockLength   DESC
    LIMIT 4
    ;

    SELECT * FROM HiMemBlocks ;

    >    blockstart | blocklength | blockcores | blockmemory
    >   ------------+-------------+------------+-------------
    >      29415943 |         120 |          2 |           2
    >      29416063 |         120 |          2 |           2
    >      29416183 |         120 |          2 |           2
    >      29416303 |         120 |          2 |           2
    >   (4 rows)


    SELECT
        *
    INTO
        HiCpuBlocks
    FROM
        ScaledBlocks
    ORDER BY
        ScaledBlocks.BlockCores    DESC,
        ScaledBlocks.BlockMemory   DESC,
        ScaledBlocks.BlockStart    ASC,
        ScaledBlocks.BlockLength   DESC
    LIMIT 4
    ;

    SELECT * FROM HiCpuBlocks ;

    >    blockstart | blocklength | blockcores | blockmemory
    >   ------------+-------------+------------+-------------
    >      29415943 |         120 |          2 |           2
    >      29416063 |         120 |          2 |           2
    >      29416183 |         120 |          2 |           2
    >      29416303 |         120 |          2 |           2
    >   (4 rows)


    SELECT
        *
    INTO
        CombinedQuery
    FROM
        (
        SELECT
            *
        FROM
            EarlyBlocks
        )
        UNION
        (
        SELECT
            *
        FROM
            HiMemBlocks
        )
        UNION
        (
        SELECT
            *
        FROM
            HiCpuBlocks
        )
    ;

    SELECT * FROM CombinedQuery ;

    >    blockstart | blocklength | blockcores | blockmemory
    >   ------------+-------------+------------+-------------
    >      29415943 |         120 |          2 |           2
    >      29416183 |         120 |          2 |           2
    >      29416063 |         120 |          2 |           2
    >      29416303 |         120 |          2 |           2
    >   (4 rows)


# -----------------------------------------------------
# Try our service ...
#[root@developer-tools]

    pushd /calycopis/java/spring/spring-webapp  ; ./mvnw clean spring-boot:run ; popd

        ....
        ....

    curl \
        --silent \
        --show-error \
        --header 'Content-Type: application/yaml' \
        --data-binary "@001-offerset-request.yaml" \
        --header 'Accept: application/yaml' \
        'http://127.0.0.1:8082/offersets' \
    | tee "002-offerset-response.yaml" \
    | yq '.'

    >   kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/offerset/execution-offerset-1.0"
    >   meta:
    >     uuid: "b06d405e-7c78-4538-8cb5-436e0966599e"
    >     name: "no-name"
    >     url: "http://127.0.0.1:8082/offersets/b06d405e-7c78-4538-8cb5-436e0966599e"
    >     created: "2025-12-05T19:00:01.154297173Z"
    >   result: "YES"
    >   offers:
    >     - kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/session/scheduled-execution-session-1.0"
    >       meta:
    >         uuid: "975b739a-6844-4fee-835b-4b832071d89d"
    >         name: "no-name-offer-0"
    >         url: "http://127.0.0.1:8082/sessions/975b739a-6844-4fee-835b-4b832071d89d"
    >         created: "2025-12-05T19:00:01.278924813Z"
    >       executable:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/executable/docker-container-1.0"
    >         meta:
    >           uuid: "ba8dffa0-71fb-45a2-a741-95fdd25fea6c"
    >           url: "http://127.0.0.1:8082/executables/ba8dffa0-71fb-45a2-a741-95fdd25fea6c"
    >           created: "2025-12-05T19:00:01.301855429Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T19:00:10Z"
    >             duration: "PT35S"
    >           available:
    >             start: "2025-12-05T19:00:45Z/PT0S"
    >           releasing:
    >             start: "2025-12-05T21:01:05Z"
    >             duration: "PT1S"
    >         privileged: false
    >       compute:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/compute/simple-compute-resource-1.0"
    >         meta:
    >           uuid: "165984cf-34f6-4d25-b0f8-8e0f846f2149"
    >           name: "Default compute resource"
    >           url: "http://127.0.0.1:8082/compute/165984cf-34f6-4d25-b0f8-8e0f846f2149"
    >           created: "2025-12-05T19:00:01.326565443Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T19:00:45Z"
    >             duration: "PT15S"
    >           available:
    >             start: "2025-12-05T19:01:00Z/PT0S"
    >             duration: "PT2H"
    >           releasing:
    >             start: "2025-12-05T21:01:05Z"
    >             duration: "PT10S"
    >         cores:
    >           min: 2
    >           max: 2
    >         memory:
    >           min: 2
    >           max: 2
    >       phase: "OFFERED"
    >       expires: "2025-12-05T19:05:01.154297910Z"
    >       schedule:
    >         preparing:
    >           start: "2025-12-05T19:00:10Z"
    >           duration: "PT50S"
    >         available:
    >           start: "2025-12-05T19:01:00Z/PT0S"
    >           duration: "PT2H"
    >         releasing:
    >           start: "2025-12-05T21:01:05Z"
    >           duration: "PT10S"
    >     - kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/session/scheduled-execution-session-1.0"
    >       meta:
    >         uuid: "2bd7759d-e692-45ce-a60f-a1217c43befd"
    >         name: "no-name-offer-1"
    >         url: "http://127.0.0.1:8082/sessions/2bd7759d-e692-45ce-a60f-a1217c43befd"
    >         created: "2025-12-05T19:00:01.340027012Z"
    >       executable:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/executable/docker-container-1.0"
    >         meta:
    >           uuid: "af5d8ba8-09ad-48c9-acfd-abea4b5c985b"
    >           url: "http://127.0.0.1:8082/executables/af5d8ba8-09ad-48c9-acfd-abea4b5c985b"
    >           created: "2025-12-05T19:00:01.352944467Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T21:00:10Z"
    >             duration: "PT35S"
    >           available:
    >             start: "2025-12-05T21:00:45Z/PT0S"
    >           releasing:
    >             start: "2025-12-05T23:01:05Z"
    >             duration: "PT1S"
    >         privileged: false
    >       compute:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/compute/simple-compute-resource-1.0"
    >         meta:
    >           uuid: "16d637bf-39bf-4122-8ff5-2fd8e5890664"
    >           name: "Default compute resource"
    >           url: "http://127.0.0.1:8082/compute/16d637bf-39bf-4122-8ff5-2fd8e5890664"
    >           created: "2025-12-05T19:00:01.371741939Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T21:00:45Z"
    >             duration: "PT15S"
    >           available:
    >             start: "2025-12-05T21:01:00Z/PT0S"
    >             duration: "PT2H"
    >           releasing:
    >             start: "2025-12-05T23:01:05Z"
    >             duration: "PT10S"
    >         cores:
    >           min: 2
    >           max: 2
    >         memory:
    >           min: 2
    >           max: 2
    >       phase: "OFFERED"
    >       expires: "2025-12-05T19:05:01.154297910Z"
    >       schedule:
    >         preparing:
    >           start: "2025-12-05T21:00:10Z"
    >           duration: "PT50S"
    >         available:
    >           start: "2025-12-05T21:01:00Z/PT0S"
    >           duration: "PT2H"
    >         releasing:
    >           start: "2025-12-05T23:01:05Z"
    >           duration: "PT10S"
    >     - kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/session/scheduled-execution-session-1.0"
    >       meta:
    >         uuid: "1db058e9-6aef-4ca4-8e8d-c661cd432ba4"
    >         name: "no-name-offer-2"
    >         url: "http://127.0.0.1:8082/sessions/1db058e9-6aef-4ca4-8e8d-c661cd432ba4"
    >         created: "2025-12-05T19:00:01.388626282Z"
    >       executable:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/executable/docker-container-1.0"
    >         meta:
    >           uuid: "b0810705-e87e-4040-ac62-3265af476f72"
    >           url: "http://127.0.0.1:8082/executables/b0810705-e87e-4040-ac62-3265af476f72"
    >           created: "2025-12-05T19:00:01.404934752Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T23:00:10Z"
    >             duration: "PT35S"
    >           available:
    >             start: "2025-12-05T23:00:45Z/PT0S"
    >           releasing:
    >             start: "2025-12-06T01:01:05Z"
    >             duration: "PT1S"
    >         privileged: false
    >       compute:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/compute/simple-compute-resource-1.0"
    >         meta:
    >           uuid: "8653ed30-f074-4ed1-b9a8-fe4b182b069d"
    >           name: "Default compute resource"
    >           url: "http://127.0.0.1:8082/compute/8653ed30-f074-4ed1-b9a8-fe4b182b069d"
    >           created: "2025-12-05T19:00:01.420177734Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-05T23:00:45Z"
    >             duration: "PT15S"
    >           available:
    >             start: "2025-12-05T23:01:00Z/PT0S"
    >             duration: "PT2H"
    >           releasing:
    >             start: "2025-12-06T01:01:05Z"
    >             duration: "PT10S"
    >         cores:
    >           min: 2
    >           max: 2
    >         memory:
    >           min: 2
    >           max: 2
    >       phase: "OFFERED"
    >       expires: "2025-12-05T19:05:01.154297910Z"
    >       schedule:
    >         preparing:
    >           start: "2025-12-05T23:00:10Z"
    >           duration: "PT50S"
    >         available:
    >           start: "2025-12-05T23:01:00Z/PT0S"
    >           duration: "PT2H"
    >         releasing:
    >           start: "2025-12-06T01:01:05Z"
    >           duration: "PT10S"
    >     - kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/session/scheduled-execution-session-1.0"
    >       meta:
    >         uuid: "81f9ab02-62e0-413d-a59f-33bd6091fe87"
    >         name: "no-name-offer-3"
    >         url: "http://127.0.0.1:8082/sessions/81f9ab02-62e0-413d-a59f-33bd6091fe87"
    >         created: "2025-12-05T19:00:01.437467528Z"
    >       executable:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/executable/docker-container-1.0"
    >         meta:
    >           uuid: "868c6c01-6c2e-4534-a25c-ac2bad454e5e"
    >           url: "http://127.0.0.1:8082/executables/868c6c01-6c2e-4534-a25c-ac2bad454e5e"
    >           created: "2025-12-05T19:00:01.457957554Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-06T01:00:10Z"
    >             duration: "PT35S"
    >           available:
    >             start: "2025-12-06T01:00:45Z/PT0S"
    >           releasing:
    >             start: "2025-12-06T03:01:05Z"
    >             duration: "PT1S"
    >         privileged: false
    >       compute:
    >         kind: "https://www.purl.org/ivoa.net/EB/schema/v1.0/types/compute/simple-compute-resource-1.0"
    >         meta:
    >           uuid: "9aedc391-1fdb-4a59-a1b1-6c4181bc093e"
    >           name: "Default compute resource"
    >           url: "http://127.0.0.1:8082/compute/9aedc391-1fdb-4a59-a1b1-6c4181bc093e"
    >           created: "2025-12-05T19:00:01.474946567Z"
    >         phase: "INITIALIZING"
    >         schedule:
    >           preparing:
    >             start: "2025-12-06T01:00:45Z"
    >             duration: "PT15S"
    >           available:
    >             start: "2025-12-06T01:01:00Z/PT0S"
    >             duration: "PT2H"
    >           releasing:
    >             start: "2025-12-06T03:01:05Z"
    >             duration: "PT10S"
    >         cores:
    >           min: 2
    >           max: 2
    >         memory:
    >           min: 2
    >           max: 2
    >       phase: "OFFERED"
    >       expires: "2025-12-05T19:05:01.154297910Z"
    >       schedule:
    >         preparing:
    >           start: "2025-12-06T01:00:10Z"
    >           duration: "PT50S"
    >         available:
    >           start: "2025-12-06T01:01:00Z/PT0S"
    >           duration: "PT2H"
    >         releasing:
    >           start: "2025-12-06T03:01:05Z"
    >           duration: "PT10S"

    #
    # Yay it works :-D
    #


# -----------------------------------------------------
# Wrap the steps in a function and call it lots of times.
#[root@container]

    createnew()
        {
        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@001-offerset-request.yaml" \
            --header 'Accept: application/yaml' \
            'http://127.0.0.1:8082/offersets' \
        > "002-offerset-response.yaml"

        curl \
            --silent \
            --show-error \
            --header 'Content-Type: application/yaml' \
            --data-binary "@003-accept-00-request.yaml" \
            --header 'Accept: application/yaml' \
            "$(yq '.offers[0].meta.url' '002-offerset-response.yaml')" \
        > "004-accept-00-response.yaml"
        }


    for x in {1..10}; do echo "Loop [${x}]" ; createnew; done

        #
        # Looking good ...
        #

    for x in {1..100}; do echo "Loop [${x}]" ; createnew; done

        #
        # Looking good ...
        #

    for x in {1..1000}; do echo "Loop [${x}]" ; createnew; done

        #
        # Takes a while to load them all in, but no issues.
        # Backlog is huge, so it will take a long time for the later ones to be picked up.
        # So the main cause of delay could be the broker itself ?
        # Not a fair test - TestProcessor.process() basically waits for ~50 seconds.
        # Multiply that by 1,000 and you get ~13 hours.
        #

        (20 * (5/2) * 1000) / (60 * 60) = 13.88

        #
        # Syntax issues aside, this is a win.
        # Using H2 database the service would slow down with 5 to 10 queries.
        # No visible slow down with 1,000 queries.
        # No optimisation.
        #

