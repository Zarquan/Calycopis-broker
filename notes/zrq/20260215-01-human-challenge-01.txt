#
# <meta:header>
#   <meta:licence>
#     Copyright (c) 2026, Manchester (http://www.manchester.ac.uk/)
#
#     This information is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This information is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this software. If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#zrq-notes-indent
#
# AIMetrics: []
#

    Target:

        Refactoring to move test code into mock components.
        https://github.com/ivoa/Calycopis-broker/issues/348

    Result:

        Success. GitHub issue foxed and PullRequest merged.
        https://github.com/ivoa/Calycopis-broker/issues/348
        https://github.com/ivoa/Calycopis-broker/pull/353

        BUT it was a slow process.
        My guess is Cursor would have done it in a fraction of the time.


# -----------------------------------------------------
# -----------------------------------------------------
# Create a new branch.
#[user@desktop]

    branchname=cursor-challenge-02
    newbranch=$(date '+%Y%m%d')-zrq-${branchname:?}

    source "${HOME:?}/calycopis.env"
    pushd "${CALYCOPIS_CODE:?}"

        git checkout main

        git checkout -b "${newbranch:?}"

    popd


# -----------------------------------------------------
# Continuing Cursor session from previous notes.
#[user@desktop]

    podman exec \
        --tty \
        --interactive \
        dev-tools \
            bash

        curl https://cursor.com/install -fsS | bash

        agent

    >   ....
    >   ....


# -----------------------------------------------------
# -----------------------------------------------------

    What do we want to do ?
    Create two sets of entities.

    TestMock classes

        SimpleComputeResourceEntity becomes abstract

        MockSimpleComputeResourceEntity
        extends SimpleComputeResourceEntity

            Properties for implementing the tests.
            Prepare resource waits for n x m loops.
            e.g. 10 x 1sec
            getPrepareTime() => 10sec

        SimpleComputeResourceEntityFactory
        replaced by
        MockSimpleComputeResourceEntityFactory


    SimpleComputeResourceValidatorImpl
    contains a reference to entity factory
    final SimpleComputeResourceEntityFactory entityFactory;


    AbstractComputeResourceValidatorFactoryImpl
    has a list of validators in its base class

        protected List<Validator<ObjectType, EntityType>> validators = new ArrayList<Validator<ObjectType, EntityType>>();

    which is autowired in the constructor

        @Autowired
        public AbstractComputeResourceValidatorFactoryImpl(final SimpleComputeResourceEntityFactory simpleComputeEntityFactory)
            {
            super();
            this.validators.add(
                new SimpleComputeResourceValidatorImpl(
                    simpleComputeEntityFactory
                    )
                );
            }

    OfferSetRequestParserImpl has a reference to a validator factory

        private final AbstractComputeResourceValidatorFactory computeValidators;

    which is autowired in the constructor

        @Autowired
        public OfferSetRequestParserImpl(
            ....
            final AbstractComputeResourceValidatorFactory computeValidators,
            ....
            ){
            super();
            ....
            this.computeValidators    = computeValidators ;
            ....
            }

    solution is to use the Platform rather than individual @Autowired parameters

        @Autowired
        public OfferSetRequestParserImpl(
            final Platform platform
            ){
            super();
            ....
            this.platform = platform ;
            ....
            }

    Add a layer of abstraction for SessionEntityFactory

        SimpleExecutionSessionEntity
        should extend
        AbstractExecutionSessionEntity
        already done

        SimpleExecutionSessionEntityFactory
        should extend
        AbstractExecutionSessionEntityFactory

        public interface AbstractExecutionSessionEntityFactory<EntityType extends AbstractExecutionSession>
        extends FactoryBase
            public Optional<EntityType> select(final UUID uuid);
            ....

    Platform should provide the validators

        public ComputeResourceOfferFactory             getOfferBlockFactory();
        public AbstractExecutableValidatorFactory      getExecutableValidators();
        public AbstractStorageResourceValidatorFactory getStorageValidators();
        public AbstractDataResourceValidatorFactory    getDataValidators();
        public AbstractVolumeMountValidatorFactory     getVolumeValidators();
        public AbstractComputeResourceValidatorFactory getComputeValidators();
        public AbstractExecutionSessionEntityFactory   getExecutionSessionFactory();


    #
    # OK, several rabbit holes later, managed ot make the changes needed to support the change we want.
    # All the validators come from the Platform interface, and we have a MockPlatform that implements it.
    # Now we can make SimpleComputeResourceEntity abstract, and MockPlatform creates MockSimpleComputeResourceEntity.
    # Getting here took ~3hrs and a lot of editing.
    # My guess is Cursor would have done it in ~3min.
    # (*) If I could have described what I wanted.
    # (**) If we actually needed to do this in the first place.
    # (***) I'll get better at letting go and letting AI do the work.
    #

    TestMock classes

        SimpleComputeResourceEntity becomes abstract

        MockSimpleComputeResourceEntity
        extends SimpleComputeResourceEntity

            Properties for implementing the tests.
            Prepare resource waits for n x m loops.
            e.g. 10 x 1sec
            getPrepareTime() => 10sec

        SimpleComputeResourceEntityFactory
        replaced by
        MockSimpleComputeResourceEntityFactory


# -----------------------------------------------------
# -----------------------------------------------------

    Does this mean we need a Mock implementation for all of the Entity classes ?
    The Mock classes have additional fields, e.g. loop counters, and a different methods.
    Much like the Podman classes ...
    So yes.

    Executable

        Each type of Executable has different information about the source.
        e.g. DockerConatiner and JupyterNotebook

        That gets split into MockDockerConatiner and PodmanDockerConatiner.
        MockDockerConatiner just uses a loop counter
        PodmanDockerConatiner checks whether the image is in the local cache.
        If not, it downloads the image to the local cache during the prepare step.

    ComputeResource

        We only have one type of SimpleComputeResource at the moment.
        That gets split into MockSimpleComputeResource and PodmanComputeResource.
        MockSimpleComputeResource just uses a loop counter
        PodmanComputeResource has additional information about the Pod


    StorageResource

        We only have one type of SimpleStorageResource at the moment.
        That gets split into MockSimpleStorageResource and PodmanSimpleStorageResource.
        MockSimpleStorageResource just uses a loop during prepare
        PodmanSimpleStorageResource has additional information about the Podman volume it represents.

    VolumeMount

        We only have one type of SimpleVolumeMount at the moment.
        That gets split into MockSimpleVolumeMount and PodmanSimpleVolumeMount.
        MockSimpleVolumeMount just uses a pause during prepare
        PodmanSimpleVolumeMount doesn't need to do anything itself.
        PodmanComputeResource manages the volume mounts


    DataResource

        Each type of DataResource has a different information about the source.
        e.g. S3DataResource and RucioDataResource

        Each type of DataResource has a different way of launching/saving/storing the data e.g. Mock and Podman.
        S3DataResource saves the information about the S3 data source.

        Then MockS3DataResource and PodmanS3DataResource implementations override the orchestration part.
        MockS3DataResource just uses a loop counter
        PodmanS3DataResource launches a S3 downloader app in the same Pod with the appropriate volume mount.









