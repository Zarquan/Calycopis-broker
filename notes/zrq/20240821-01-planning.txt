#
# <meta:header>
#   <meta:licence>
#     Copyright (c) 2024, Manchester (http://www.manchester.ac.uk/)
#
#     This information is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This information is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#zrq-notes-indent
#
# AIMetrics: []
#

    Target:

        Where next ..

    Result:

        Work in progress ...

# -----------------------------------------------------

    Where next ..

        Add logging - done
        Picked a recent article to get the latest fashion.
        https://www.baeldung.com/java-logging-intro
        https://medium.com/@bishalf98/log4j2-in-springboot3-095ab6f15763

        Limit to 4 offers - done

        Comment on current feature - done
        Describe document feature - Susana starting Dave added suggestions.

        Test future start date - done
        Works BUT it ignores the Period part of the Interval
        It interprets it as 'after' the start time rather than
        'within' the interval.
            requested:
              - start: 2024-08-30T09:45:00Z/PT1H
                duration:
                  min: PT2H
            offered:
              executing:
                start: "2024-08-30T09:45:00Z"
                duration: "PT2H"
            offered:
              executing:
                start: "2024-08-30T11:45:00Z"
                duration: "PT2H"
            offered:
              executing:
                start: "2024-08-30T13:45:00Z"
                duration: "PT2H"
            offered:
              executing:
                start: "2024-08-30T15:45:00Z"
                duration: "PT2H"

        New git branch ..

        State in the database - done
        Expiry date in database - done
        Sweep to clear expired - done

        Code to progress state machine.
        Poke to progress state machine.

        Leave VOSpace code as stubs.

        Script demo to show state progression.

# -----------------------------------------------------

        Code to progress state machine.
        Poke to progress state machine.

        What if we moved the transfers into another service.
        stagequote   -> returns quote for time cost
        stageexecute -> performs action, with callback
            single function webservice, kicks off the transfer in the background
            callback when done

        quote data
            quote time cost to transfer data
            (sync)

        prepare session directory
            VOSpace create directory
            /home/{username}/broker/{sessionuuid}
            (sync)

        prepare notebook
            transfer notebook into session directory
            notebook metadata includes location and md5
            notebook:
                location:
                  url: ...
                checks:
                  size: ...
                  md5: ....
            (async)

        transfer data
            resource:
                location:
                  url: ...
                checks:
                  size: ...
                  md5: ....
            check if already present
                check checksum
                pass if same
                fail if differet
            else
                transfer into session directory
                pass on complete
            callback to EB
            (async)

        execute notebook
            CANFAR launch session
            (sync)

        complete notebook
            CANFAR close session
            (sync)

        It means another service, but it keeps the EB code simpler.
        Offload the deatils into another single function service.

        EB needs to keep track of the concurrent tasks it has launched.
        Callback ticks off each task with a single update.
        Then IF all the updates are done, more to the next stage.

        We can simulate the transfer service manually.
        We can trigger the callnback manually.

        Do we implement in Java or Python ?
        There is a CADC Java client (requires cert)
        https://central.sonatype.com/artifact/org.opencadc/cadc-vos-client

        Does Spaninsh VOSpace support cert or just token ?

# -----------------------------------------------------

    ExecutionBroker

        Quoting

            foreach data
                quote data
                    quote time cost to transfer data
                    (sync)

        Preparing

            maintain a list of things that need to happen before it can start
            List<Task> tasklist

                // Count of completed tasks
                int done

                // Preparing is 'done' when count == size
                (done == tasklist.size())

            prepare session directory
                VOSpace create directory
                /home/{username}/broker/{sessionuuid}
                (sync)

            prepare notebook
                transfer notebook into session directory
                notebook metadata includes location and md5
                notebook:
                    location:
                      url: ...
                    checks:
                      size: ...
                      md5: ....
                (async)

            transfer data
                resource:
                    location:
                      url: ...
                    checks:
                      size: ...
                      md5: ....
                check if already present
                    check checksum
                    pass if same
                    fail if differet
                else
                    transfer into session directory
                    pass on complete
                callback to EB
                (async)

        process the list of data resources and volume mounts
        add a Task to the List for each thing
        each task kicks off a remote service passing a callback URL

        the callbacks set the Task state and update the execution state
        if ALL Tasks are completed, execution state is incremented to WAITING

            DROP TABLE IF EXISTS example ;
            CREATE TABLE example (
                ident INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                status CHAR VARYING
                );
            INSERT INTO example (status) VALUES('RUNNING');
            INSERT INTO example (status) VALUES('RUNNING');
            INSERT INTO example (status) VALUES('COMPLETED');
            INSERT INTO example (status) VALUES('COMPLETED');

            -- count each group and the whole set
            -- https://stackoverflow.com/a/60004149
            SELECT status, count(status), sum(count(*)) over () FROM example GROUP BY status
            STATUS      COUNT(STATUS)   SUM(COUNT(*)) OVER ()  
            COMPLETED   2               4
            RUNNING     2               4
            (2 rows, 0 ms)

            done when there is one row and the counts are equal

            SELECT
                status,
                count(status) AS StatusCount,
                (SELECT COUNT(*) FROM example) AS TotalCount
            FROM
                example
            WHERE
                status = 'COMPLETED'

            STATUS      STATUSCOUNT TOTALCOUNT  
            COMPLETED   2   4
            (1 row, 2 ms)

            done when the counts are equal

        cron update looks for execution with state WAITING and starttime < now
        cron update starts the execution and moves status to RUNNING

        Manual HTTP trigger for cron tasks for now.
        Investigate Quartz another time.
        https://www.baeldung.com/quartz

        Not clear if Quartz manages database sessions.

# -----------------------------------------------------

        OK, separate micro services it is.

        OpenAPI based, using parts of the same data model as EB.
        Split the EB schema into parts and include them using $ref.
        https://swagger.io/docs/specification/using-ref/

        Java/Spring based because .. ?
        Because we already have some, so it is more of the same.

        Separate SRCNet Feature to port the code into Python.

        Cheat and put the certs/tokens on disc ..

        ExecutionBroker maintains a list of things todo.
        List<Task> tasklist

        Processing data resource adds a Task to the list.
        Processing executable adds a Task to the list.

        Tasks lie dormant until the ExecutionBroker block moves from
        ACCEPTED to PREPARING

        ExecutionBroker block status updated to PREPARING when
        (status = ACCEPTED) AND ((startime - sum(task-quote)) < now()

            If tasks are sequential use sum(task-quote)
            If tasks are parallel use max(task-quote)

        Tasks make a call to a remote service to kick them off.
        Call includes a callback URL to update when done.
        * Need to have a deliberate break to prevent nested callback before the request completes.
        * Request kicks off a new Thread in the MicroService with a 1s delay at the start.
        * ExecutionBroker updates the task status to RUNNING.
        * Callback backs off if the status isn't already RUNNING.

        ExecutionBroker moves to the next stage when all the tasks are done.
        See above for SQL to transition RUNNING -> WAITING

        Cron looks for ExecutionBroker blocks with (status WAITING) AND (starttime < now).
        Kicks off the execution.

# -----------------------------------------------------

        Prepare the executable

            Session prepartion is create the home directory

            Notebook prepartion is transfer the file.
            Possibly transfer the requirements ?

            DataResource prepartion is transfer the file.
            Check if it is present.
            Quote is based on a fixed table.
                here - 1m
                not here - 1h

            Check if it is present.
                Force replacement ?
            Transfer if required.

# -----------------------------------------------------

    ExecutionBlock state stored in database
    ExecutionResponse stored in memory in HashMap

    ExecutionResponse is a complex tree of polymorphic objects.
    ExecutionBlock is a simplified minimal table.

    Link between ExecutionBlock and ExecutionResponse is the UUID.
    * When the ExecutionBlock is deleted from DB, we should delete the corresponding ExecutionResponse from the HashMap.
    * How do we get a list of deleted blocks ?
    * Huge memory leak issues.
    * Ignore it for the demo.

    When we implement proper persitance using Hibernate
    the main business logic class would be Execution.
    ExecutionResponse is just the serialization in messages.
    ExecutionBlock can be implemented as a view on Execution.

# -----------------------------------------------------

    Define the status change callback.

    Simple POST request that triggers internal status change.

    /callback/{taskident}

        update:
          state:
            COMPLETED
            CANCELLED
            FAILED
        response:
          state:
            ....

    More complex tasks can have their own callback messages.

        TaskStateEnum
            CREATED
            RUNNING
            COMPLETED
            CANCELLED
            FAILED

    On the callout to the micro-service, the mains service sets
    the state from CREATED to RUNNING.
    The new state will only be visible *after* the transaction completes.

    The callback checks the state and only makes the progression
    from RUNNING to COMPLETED if the state is already RUNNING.
    The callback call returns the current state in the response.

    If we a callback happens before the callout has completyed,
    the state will still be CREATED.
    In which case the micro-service should pause and try again.


    interface PreparationStep
        UUID uuid
        UUID parent -> execution/block
        StateEnum state
            CREATED
            RUNNING
            COMPLETED
            CANCELLED
            FAILED

        start();
        run(); <- Runnable in Thread
        complete();
        cancel();
        fail();

    PreparationStepImpl

    class PreparationStepFactory

        PreparationStep select(uuid)
        List<PreparationStep> select(parent)

    interface CanfarPreparationStep extends extends PreparationStep

    class CanfarPreparationStep

        @Override
        void run()
            {
            Call the VOSpace service to create working directory.
            }


    Where do we put the working directory path ?
    Platform (CANFAR) specific data for the Execution.
    Add to the Execution properties ?
    canfar.home = /home/{user}/broker/{execution}/

    Or we define a new class
    interface CanfarExecution extends PlatformExecution
        {
        String getUserName();
        String getSessionHome();
        }

    CanfarExecutionImpl extends ExecutionResponseImpl
    implements CanfarExecution
        {
        ....
        }

    interface CanfarPreparationStep extends PreparationStep
        {
        CanfarExecution getParent();
        }

    class CanfarPreparationImpl implements CanfarPreparationStep
        {
        @Override
        void run()
            {
            Call the VOSpace service to create working directory.
            }
        }

    interface DataStagingStep extends PreparationStep

        volume: -> volume mount
          compute:  -> compute resource
          resource: -> data resource

    interface VOSpaceStagingStep extends DataStagingStep

    class VOSpaceStagingImpl extends DataStagingImpl extends PreparationStepImpl
        {
        @Override
        void run()
            {
            transfer data from external resource into local VOSpace
            }
        }

    Processing a CanfarExecution adds steps to the execution.

    CanfarExecutionImpl

        String getUserName();
        String getSessionHome();
        void setSessionHome(String path);

        void process()
            {
            steps.add(
                new CanfarPreparationStepImpl(
                    this
                    )
                )
            for each volume mount
                {
                steps.add(
                    new VOSpaceStagingImpl(
                        volume,
                        canfarstep.getSessionHome()
                        )
                    );
                }
            }


