# generated by fastapi-codegen:
#   filename:  /ivoa/openapi-0.6.yaml
#   timestamp: 2024-07-09T19:49:05+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field


class MinMaxInteger(BaseModel):
    min: Optional[int] = None
    max: Optional[int] = None
    units: Optional[str] = None


class MinMaxFloat(BaseModel):
    min: Optional[float] = None
    max: Optional[float] = None
    units: Optional[str] = None


class MinMaxString(BaseModel):
    min: Optional[str] = None
    max: Optional[str] = None
    units: Optional[str] = None


class NameValueMap(BaseModel):
    __root__: Optional[Dict[str, str]] = None


class AbstractComponent(BaseModel):
    ident: Optional[UUID] = None
    name: Optional[str] = None
    properties: Optional[NameValueMap] = Field(
        None, description='A map of name-value properties.\n'
    )


class AbstractPolymorph(AbstractComponent):
    type: str


class AbstractComputeResource(AbstractPolymorph):
    type: str


class Mode(Enum):
    READONLY = 'READONLY'
    READWRITE = 'READWRITE'


class ComputeResourceVolume(AbstractComponent):
    path: Optional[str] = Field(
        None, description='The mount point in the target filesystem.\n'
    )
    mode: Optional[Mode] = Field(None, description='The read-write mode.\n')
    resource: Optional[str] = Field(
        None, description='The name or ident of the resource to mount.\n'
    )


class AbstractStorageResource(AbstractPolymorph):
    type: str


class SimpleStorageResource(AbstractStorageResource):
    size: Optional[MinMaxInteger] = Field(
        None,
        description='The size of storage required, specified in SI units. Default units are `GiB`.\n',
    )


class AbstractDataResource(AbstractPolymorph):
    type: str


class SimpleDataResource(AbstractDataResource):
    location: Optional[str] = Field(
        None, description='The URL of the data to import.\n'
    )


class S3DataResource(AbstractDataResource):
    endpoint: Optional[str] = Field(
        None, description='The endpoint address of the S3 service.\n'
    )
    template: Optional[str] = Field(
        None, description='The URL template for the S3 service.\n'
    )
    bucket: Optional[str] = Field(None, description='The target bucket name.\n')
    object: Optional[str] = Field(
        None,
        description='The target object name.\nLeaving this blank will mount the whole bucket as a directory.\n',
    )


class AbstractExecutable(AbstractPolymorph):
    type: str


class Protocol(Enum):
    UDP = 'UDP'
    TCP = 'TCP'
    HTTP = 'HTTP'
    HTTPS = 'HTTPS'


class DockerNetworkPort(BaseModel):
    address: Optional[str] = Field(
        None,
        description='The IP address of the external network interface. The client should not set this value. The service will update this with the corrent public interface address when it sets up the execution.\n',
    )
    external: Optional[str] = Field(
        None,
        description="The host machine's external port number to connect. The client should not set this value. The service will update this with the corrent port number when it sets up the execution.\n",
    )
    internal: str = Field(
        ..., description='The port number on the container to publish.'
    )
    protocol: Optional[Protocol] = Field(
        None,
        description='The network protocol to use, default is `TCP`. The `HTTP` and `HTTPS` values further specify the Protocol to use on top of `TCP`. Specifying `HTTPS` may help to meet firewall restrictions at some sites.\n',
    )


class SingularContainer01(AbstractExecutable):
    image: str = Field(
        ..., description='The URL to download the container image from.\n'
    )


class Repo2DockerContainer01(AbstractExecutable):
    source: str = Field(..., description='The URL of the repository to package.\n')


class JupyterNotebook01(AbstractExecutable):
    notebook: str = Field(
        ...,
        description='The URL of the notebook. TODO - This needs to take into account different ways of referring to a notebook.\n',
    )


class BinderNotebook01(AbstractExecutable):
    repository: str = Field(..., description='The URL of the repository to package.\n')
    notebook: Optional[str] = Field(
        None, description='The relative path of the notebook within the repository.\n'
    )


class ComputeResourceList(BaseModel):
    __root__: List[AbstractComputeResource] = Field(
        ..., description='A list of compute resources.\n'
    )


class StorageResourceList(BaseModel):
    __root__: List[AbstractStorageResource] = Field(
        ..., description='A list of storage resources.\n'
    )


class DataResourceList(BaseModel):
    __root__: List[AbstractDataResource] = Field(
        ..., description='A list of data resources.\n'
    )


class OptionBase(BaseModel):
    type: str
    path: str = Field(..., description='The target path that the option applies to.\n')


class StringValueOption(OptionBase):
    pattern: Optional[str] = Field(
        None, description='A regular expression pattern restricting the value.\n'
    )


class EnumValueOption(OptionBase):
    values: List[str] = Field(..., description='The list of allowed values to use.\n')


class IntegerValueOption(OptionBase):
    min: Optional[int] = Field(None, description='The minimum value that can be set.\n')
    max: Optional[int] = Field(None, description='The maximum value that can be set.\n')
    units: Optional[str] = Field(
        None,
        description='The units used for the maximum and minimum values and the default units used for the update. The client may specify different units in the update if they need to.\n',
    )


class IntegerDeltaOption(OptionBase):
    min: Optional[int] = Field(
        None, description='The minimum change that can be applied.\n'
    )
    max: Optional[int] = Field(
        None, description='The maximum change that can be applied.\n'
    )
    units: Optional[str] = Field(
        None,
        description='The units used for the maximum and minimum values and the default units used for the update. The client may specify different units in the update if they need to.\n',
    )


class UpdateBase(BaseModel):
    type: str
    path: str = Field(..., description='The target path that the update applies to.\n')


class StringValueUpdate(UpdateBase):
    value: str = Field(..., description='The string value to use.\n')


class EnumValueUpdate(UpdateBase):
    value: str = Field(..., description='The enum value to use.\n')


class IntegerValueUpdate(UpdateBase):
    value: int = Field(..., description='The integer value to use.\n')
    units: Optional[str] = Field(None, description='The units to use for the value.\n')


class IntegerDeltaUpdate(UpdateBase):
    delta: int = Field(..., description='The increment or decrement to apply.\n')
    units: Optional[str] = Field(None, description='The units to use for the change.\n')


class ExecutionDuration(BaseModel):
    min: Optional[str] = None
    max: Optional[str] = None


class ExecutionScheduleItem(BaseModel):
    start: Optional[str] = Field(
        None,
        description='The start time for the execution, expressed as an ISO 8601 time interval. See : https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n',
    )
    duration: Optional[ExecutionDuration] = Field(
        None, description='The duration for the execution.\n'
    )


class ExecutionResourceList(BaseModel):
    compute: Optional[ComputeResourceList] = None
    storage: Optional[StorageResourceList] = None
    data: Optional[DataResourceList] = None


class Status(Enum):
    OFFERED = 'OFFERED'
    ACCEPTED = 'ACCEPTED'
    REJECTED = 'REJECTED'
    EXPIRED = 'EXPIRED'


class OfferStatus(BaseModel):
    status: Optional[Status] = Field(
        None,
        description='Setting the status of an offer to `REJECTED` will reject the offer.\nSetting the status of an offer to `ACCEPTED` will start the execution process\nand the status of any sibling offers will automatically be set to `REJECTED`.\n',
    )
    expires: Optional[datetime] = Field(
        None, description='The date and time that this offer expires.\n'
    )


class Status1(Enum):
    WAITING = 'WAITING'
    STANDUP = 'STANDUP'
    RUNNING = 'RUNNING'
    TEARDOWN = 'TEARDOWN'
    COMPLETED = 'COMPLETED'
    CANCELLED = 'CANCELLED'
    FAILED = 'FAILED'


class ExecutionStatus(BaseModel):
    started: Optional[datetime] = None
    completed: Optional[datetime] = None
    status: Optional[Status1] = Field(
        None, description='Status code for the execution.\n'
    )


class ExecutionBase(BaseModel):
    executable: Optional[AbstractExecutable] = None
    resources: Optional[ExecutionResourceList] = None
    schedule: Optional[List[ExecutionScheduleItem]] = None


class ExecutionFull(ExecutionBase):
    offer: Optional[OfferStatus] = Field(None, description='The offer status.\n')
    execution: Optional[ExecutionStatus] = Field(
        None, description='The execution status.\n'
    )


class OffersRequest(ExecutionBase):
    pass


class Result(Enum):
    YES = 'YES'
    NO = 'NO'


class OffersResponse(BaseModel):
    result: Optional[Result] = Field(
        None,
        description='A flag to indicate whether the request can be handled by this service. If service is able to handle the request, then the `result` will be `YES` and the `offers` block should contain one or more offers. If service is not able to handle the request, the `result` will be `NO` and the `messages` block may contain one or more reasons explaining why.\n',
    )
    offers: Optional[List[ExecutionFull]] = Field(
        None,
        description='If the response is `YES`, this list should contain one or more offers describing how the request can be handled.\n',
    )
    messages: Optional[List[str]] = Field(
        None,
        description="If the response is `NO`, this list may contain one or more messages explaining why the request can't be handled.\n",
    )


class ExecutionUpdateRequest(UpdateBase):
    pass


class ExecutionStatusResponse(ExecutionFull):
    options: Optional[List[OptionBase]] = None


class SimpleComputeResource(AbstractComputeResource):
    cores: Optional[MinMaxInteger] = Field(
        None,
        description='The number of cpu cores required. Default units of `cores` are equivalent to a single physical cpu core. Use `milli cores` or `m cores` to specify Kubernetes 1/1000 values.\n',
    )
    memory: Optional[MinMaxInteger] = Field(
        None,
        description='The size of memory required. Specified in SI units, default is `GiB`.\n',
    )
    volumes: Optional[List[ComputeResourceVolume]] = Field(
        None, description='A list of resources that need to be mounted as volumes.\n'
    )


class DockerNetworkSpec(BaseModel):
    ports: Optional[List[DockerNetworkPort]] = Field(
        None, description='An array of network ports to publish.\n'
    )


class DockerContainer01(AbstractExecutable):
    image: str = Field(
        ...,
        description='The image name, with or without the repository, namespace or tag.\n',
        example="'`ghcr.io/ivoa/oligia-webtop:ubuntu-2022.01.13`, `ivoa/oligia-webtop` or just `oligia-webtop`.'\n",
    )
    namespace: Optional[str] = Field(
        None,
        description='The namespace within the repository, if not already specified in the image name.\n',
        example="'`ivoa`'\n",
    )
    tag: Optional[str] = Field(
        None,
        description='The image tag, if not already specified in the image name.',
        example="'`ubuntu-2022.01.13`'\n",
    )
    repository: Optional[str] = Field(
        None,
        description='The respository tag, if not already specified in the image name.',
        example="'`ghcr.io`'\n",
    )
    platform: Optional[str] = Field(
        None,
        description='The target CPU architecture the container is built for. The default is `linux/amd64`.\n',
    )
    privileged: Optional[bool] = Field(
        False,
        description='Set the privileged flag on execution. The default is `false`. See https://docs.docker.com/reference/cli/docker/container/run/#privileged.\n',
    )
    entrypoint: Optional[str] = None
    environment: Optional[NameValueMap] = None
    network: Optional[DockerNetworkSpec] = None
